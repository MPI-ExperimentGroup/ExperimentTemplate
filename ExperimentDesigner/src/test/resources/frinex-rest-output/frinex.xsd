<?xml version="1.0" encoding="UTF-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:simpleType name="rgbHexValue">
<xs:restriction base="xs:token">
<xs:pattern value="#[\dA-Fa-f]{6}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="booleanToggle">
<xs:restriction base="xs:string">
<xs:enumeration value="false"/>
<xs:enumeration value="true"/>
<xs:enumeration value="invert"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="rangesValue">
<xs:restriction base="xs:token">
<xs:pattern value="[0-9]*((..|,)[0-9]+)*"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="lowercaseValue">
<xs:restriction base="xs:string">
<xs:pattern value="[a-z]([a-z_0-9]){3,}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="postName">
<xs:restriction base="xs:string">
<xs:pattern value="[a-zA-Z]([a-zA-Z_0-9]){2,}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="groupMembers">
<xs:restriction base="xs:string">
<xs:pattern value="[A-Za-z_0-9]+(,[A-Za-z_0-9]+)+"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="groupChannels">
<xs:restriction base="xs:string">
<xs:pattern value="[A-Za-z_0-9]+(,[A-Za-z_0-9]+)*(\|[A-Za-z_0-9]+(,[A-Za-z_0-9]+)*)*"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="groupPhases">
<xs:restriction base="xs:string">
<xs:pattern value="(-|([A-Za-z_0-9]+(,[A-Za-z_0-9]+)*))(:(-|([A-Za-z_0-9]+(,[A-Za-z_0-9]+)*)))*"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="dateValue">
<xs:restriction base="xs:string">
<xs:pattern value="[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="presenterName">
<xs:restriction base="xs:string">
<xs:pattern value="[a-zA-Z_0-9]{3,}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="stimulusIdentifier">
<xs:restriction base="xs:string">
<xs:pattern value="[^-]{1,}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="stimulusTag">
<xs:restriction base="xs:string">
<xs:pattern value="([^\p{P}\W]*[_]*){1,}"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="stimulusTags">
<xs:restriction base="xs:string">
<xs:pattern value="([^\p{P}\W]*[ _]*)*"/>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="integerList">
<xs:list itemType="xs:integer"/>
</xs:simpleType>
<xs:simpleType name="orientationType">
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="horizontal"/>
<xs:enumeration value="vertical"/>
<xs:enumeration value="flow"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="hotKeyType">
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="A"/>
<xs:enumeration value="B"/>
<xs:enumeration value="C"/>
<xs:enumeration value="D"/>
<xs:enumeration value="E"/>
<xs:enumeration value="F"/>
<xs:enumeration value="G"/>
<xs:enumeration value="H"/>
<xs:enumeration value="I"/>
<xs:enumeration value="J"/>
<xs:enumeration value="K"/>
<xs:enumeration value="L"/>
<xs:enumeration value="M"/>
<xs:enumeration value="N"/>
<xs:enumeration value="O"/>
<xs:enumeration value="P"/>
<xs:enumeration value="Q"/>
<xs:enumeration value="R"/>
<xs:enumeration value="S"/>
<xs:enumeration value="T"/>
<xs:enumeration value="U"/>
<xs:enumeration value="V"/>
<xs:enumeration value="W"/>
<xs:enumeration value="X"/>
<xs:enumeration value="Y"/>
<xs:enumeration value="Z"/>
<xs:enumeration value="ZERO"/>
<xs:enumeration value="ONE"/>
<xs:enumeration value="TWO"/>
<xs:enumeration value="THREE"/>
<xs:enumeration value="FOUR"/>
<xs:enumeration value="FIVE"/>
<xs:enumeration value="SIX"/>
<xs:enumeration value="SEVEN"/>
<xs:enumeration value="EIGHT"/>
<xs:enumeration value="NINE"/>
<xs:enumeration value="NUM_ZERO"/>
<xs:enumeration value="NUM_ONE"/>
<xs:enumeration value="NUM_TWO"/>
<xs:enumeration value="NUM_THREE"/>
<xs:enumeration value="NUM_FOUR"/>
<xs:enumeration value="NUM_FIVE"/>
<xs:enumeration value="NUM_SIX"/>
<xs:enumeration value="NUM_SEVEN"/>
<xs:enumeration value="NUM_EIGHT"/>
<xs:enumeration value="NUM_NINE"/>
<xs:enumeration value="NUM_MULTIPLY"/>
<xs:enumeration value="NUM_PLUS"/>
<xs:enumeration value="NUM_MINUS"/>
<xs:enumeration value="NUM_PERIOD"/>
<xs:enumeration value="NUM_DIVISION"/>
<xs:enumeration value="ALT"/>
<xs:enumeration value="BACKSPACE"/>
<xs:enumeration value="CTRL"/>
<xs:enumeration value="DELETE"/>
<xs:enumeration value="DOWN"/>
<xs:enumeration value="END"/>
<xs:enumeration value="ENTER"/>
<xs:enumeration value="ESCAPE"/>
<xs:enumeration value="HOME"/>
<xs:enumeration value="LEFT"/>
<xs:enumeration value="PAGEDOWN"/>
<xs:enumeration value="PAGEUP"/>
<xs:enumeration value="RIGHT"/>
<xs:enumeration value="SHIFT"/>
<xs:enumeration value="TAB"/>
<xs:enumeration value="UP"/>
<xs:enumeration value="F1"/>
<xs:enumeration value="F2"/>
<xs:enumeration value="F3"/>
<xs:enumeration value="F4"/>
<xs:enumeration value="F5"/>
<xs:enumeration value="F6"/>
<xs:enumeration value="F7"/>
<xs:enumeration value="F8"/>
<xs:enumeration value="F9"/>
<xs:enumeration value="F10"/>
<xs:enumeration value="F11"/>
<xs:enumeration value="F12"/>
<xs:enumeration value="PAUSE"/>
<xs:enumeration value="SPACE"/>
<xs:enumeration value="R1_MA_A"/>
<xs:enumeration value="R1_MA_ENTER"/>
<xs:enumeration value="R1_MA_BACK"/>
<xs:enumeration value="R1_MA_LEFT"/>
<xs:enumeration value="R1_MA_RIGHT"/>
<xs:enumeration value="R1_MB_A"/>
<xs:enumeration value="R1_MB_B"/>
<xs:enumeration value="R1_MB_C"/>
<xs:enumeration value="R1_MB_D"/>
<xs:enumeration value="R1_MB_ENTER"/>
<xs:enumeration value="R1_MB_BACK"/>
<xs:enumeration value="R1_MC_A"/>
<xs:enumeration value="R1_MC_B"/>
<xs:enumeration value="R1_MC_C"/>
<xs:enumeration value="R1_MC_D"/>
<xs:enumeration value="R1_MC_ENTER"/>
<xs:enumeration value="R1_MC_BACK"/>
<xs:enumeration value="R1_MD_A"/>
<xs:enumeration value="R1_MD_B"/>
<xs:enumeration value="LP310_UP"/>
<xs:enumeration value="LP310_UP_LONG_A"/>
<xs:enumeration value="LP310_UP_LONG_B"/>
<xs:enumeration value="LP310_DOWN"/>
<xs:enumeration value="LP310_DOWN_LONG"/>
<xs:enumeration value="LP310_MIDDLE"/>
<xs:enumeration value="LP310_MIDDLE_LONG"/>
<xs:enumeration value="LP310_MIDDLE_DOUBLE"/>
<xs:enumeration value=""/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="recordingFormatType">
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="wav"/>
<xs:enumeration value="ogg"/>
<xs:enumeration value="ogv"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
</xs:restriction>
</xs:simpleType>
<xs:simpleType name="dtmfType">
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="0"/>
<xs:enumeration value="1"/>
<xs:enumeration value="2"/>
<xs:enumeration value="3"/>
<xs:enumeration value="4"/>
<xs:enumeration value="5"/>
<xs:enumeration value="6"/>
<xs:enumeration value="7"/>
<xs:enumeration value="8"/>
<xs:enumeration value="9"/>
<xs:enumeration value="A"/>
<xs:enumeration value="B"/>
<xs:enumeration value="C"/>
<xs:enumeration value="D"/>
<xs:enumeration value="*"/>
<xs:enumeration value="#"/>
<xs:enumeration value="off"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
</xs:restriction>
</xs:simpleType>
<xs:element name="experiment">
<xs:annotation>
<xs:documentation>Each experiment XML configuration file must have one "experiment" element of which only one is permitted and it must contain all other elements of the configuration file.</xs:documentation>
</xs:annotation>
<xs:complexType>
<xs:sequence>
<xs:element name="preventWindowClose" minOccurs="0">
<xs:complexType>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="deployment" minOccurs="0">
<xs:complexType>
<xs:attribute name="publishDate" type="dateValue">
<xs:annotation>
<xs:documentation>The date from which the experiment will be deployed.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="expiryDate" type="dateValue">
<xs:annotation>
<xs:documentation>The date after which the experiment can be undeployed.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stagingServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which staging server the experiment is deployed to.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="productionServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which production server the experiment is deployed to.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="frinexVersion" type="xs:string">
<xs:annotation>
<xs:documentation>By default the version of Frinex used to compile the experiment is determined by the noNamespaceSchemaLocation attribute in the experiment element which is also used by XML editors to validate the XML. However when frinexVersion is provided it will override the noNamespaceSchemaLocation attribute. (Regardless of which method is used to determine the version of Frinex being compiled the specified version must be available on the build server at the time of compilation).</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stunServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which stun server will be used for group experiments which stream the participants camera, microphone or canvas. When not provided no stun server will be used and any group streaming will have to be within the same local area network.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isWebApp" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true a web version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isDesktop" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true a desktop version of this experiment will be generated. To debug the desktop app you can run pass the --debug-mode switch from the terminal. This is only available in the non production versions. On osX this can be done with &quot;open with_stimulus_example.app --args --debug-mode&quot; and on Windows &quot;with_stimulus_example.exe --debug-mode&quot;.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isiOS" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true an iOS version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isAndroid" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true an Android version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isUnity" type="xs:boolean">
<xs:annotation>
<xs:documentation>Experimental feature, if true a Unity version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isVirtualReality" type="xs:boolean">
<xs:annotation>
<xs:documentation>Experimental feature, if true an UnrealEngine version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="state" use="required">
<xs:annotation>
<xs:documentation>The type of deployment to be run when changes are pushed to the build server. Validate will check the XML. Debug will build a version that produces a staging version that outputs more debug information. Draft will build a staging version faster but might not be as reliable in different browsers. Staging will deploy only to the staging server and any existing production deployment will be unaffected. Production will deploy both staging and production and can only be done when the previous production version, if it exists, has been undeployed. Undeploy will remove the experiment from both the staging and production servers. While undeployment will make the database unaccessible the data remains unaffected and will be there for future deployments. Transfer releases ownership of the experiment to allow it to be built from an other GIT repository.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="validate"/>
<xs:enumeration value="debug"/>
<xs:enumeration value="draft"/>
<xs:enumeration value="staging"/>
<xs:enumeration value="production"/>
<xs:enumeration value="undeploy"/>
<xs:enumeration value="transfer"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="validationService" minOccurs="0" type="validationServiceType"/>
<xs:element name="administration" minOccurs="0" type="administrationType"/>
<xs:element name="scss" minOccurs="0" type="xs:string"/>
<xs:element name="metadata" type="metadataType"/>
<xs:element name="presenter" maxOccurs="unbounded" type="presenterType"/>
<xs:element name="stimuli" type="stimuliType"/>
</xs:sequence>
<xs:attribute name="appNameDisplay" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="appNameInternal" type="lowercaseValue">
<xs:annotation>
<xs:documentation>String Lowercase</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="backgroundColour" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="complementColour0" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="complementColour1" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="complementColour2" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="complementColour3" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="complementColour4" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="primaryColour0" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="primaryColour1" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="primaryColour2" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="primaryColour3" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="primaryColour4" type="rgbHexValue">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="defaultLocale" type="xs:string">
<xs:annotation>
<xs:documentation>The default locale to be shown when the user preferred locale is not specified. For example &quot;en&quot; or &quot;en_GB&quot;.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="availableLocales" type="xs:string">
<xs:annotation>
<xs:documentation>List of all locales provided in this experiment. The list of locales must be comma separated without whitespace characters. For example &quot;en,de,nl,es&quot; or &quot;en_GB,en_US,en_SG&quot;.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isScalable" type="xs:boolean">
<xs:annotation>
<xs:documentation>Boolean</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="preserveLastState" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the use of browser navigation buttons will be restricted.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="splashPresenter" type="presenterName">
<xs:annotation>
<xs:documentation>When provided the named presenter will be used as the initial presenter on page reloads.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="userIdGetParam" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="rotatable" type="xs:boolean">
<xs:annotation>
<xs:documentation>Boolean</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showMenuBar" type="xs:boolean">
<xs:annotation>
<xs:documentation>Boolean</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="defaultScale" type="xs:decimal">
<xs:annotation>
<xs:documentation>Decimal Number</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="textFontSize" type="xs:integer">
<xs:annotation>
<xs:documentation>Integral Number</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="obfuscateBrowserStorage" type="xs:boolean">
<xs:annotation>
<xs:documentation>Boolean: By default the browser local storage is obfuscated to make it difficult to cheat the system, by setting this to false the obfuscation can be disabled making it easier to debug the application. This can also be achieved by adding the get parameter '?debug=true' to the URL.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:complexType name="deploymentType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
<xs:attribute name="publishDate" type="dateValue">
<xs:annotation>
<xs:documentation>The date from which the experiment will be deployed.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="expiryDate" type="dateValue">
<xs:annotation>
<xs:documentation>The date after which the experiment can be undeployed.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stagingServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which staging server the experiment is deployed to.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="productionServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which production server the experiment is deployed to.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="frinexVersion" type="xs:string">
<xs:annotation>
<xs:documentation>By default the version of Frinex used to compile the experiment is determined by the noNamespaceSchemaLocation attribute in the experiment element which is also used by XML editors to validate the XML. However when frinexVersion is provided it will override the noNamespaceSchemaLocation attribute. (Regardless of which method is used to determine the version of Frinex being compiled the specified version must be available on the build server at the time of compilation).</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stunServer" type="xs:string">
<xs:annotation>
<xs:documentation>When provided determines which stun server will be used for group experiments which stream the participants camera, microphone or canvas. When not provided no stun server will be used and any group streaming will have to be within the same local area network.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isWebApp" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true a web version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isDesktop" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true a desktop version of this experiment will be generated. To debug the desktop app you can run pass the --debug-mode switch from the terminal. This is only available in the non production versions. On osX this can be done with &quot;open with_stimulus_example.app --args --debug-mode&quot; and on Windows &quot;with_stimulus_example.exe --debug-mode&quot;.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isiOS" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true an iOS version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isAndroid" type="xs:boolean">
<xs:annotation>
<xs:documentation>If true an Android version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isUnity" type="xs:boolean">
<xs:annotation>
<xs:documentation>Experimental feature, if true a Unity version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isVirtualReality" type="xs:boolean">
<xs:annotation>
<xs:documentation>Experimental feature, if true an UnrealEngine version of this experiment will be generated.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="state" use="required">
<xs:annotation>
<xs:documentation>The type of deployment to be run when changes are pushed to the build server. Validate will check the XML. Debug will build a version that produces a staging version that outputs more debug information. Draft will build a staging version faster but might not be as reliable in different browsers. Staging will deploy only to the staging server and any existing production deployment will be unaffected. Production will deploy both staging and production and can only be done when the previous production version, if it exists, has been undeployed. Undeploy will remove the experiment from both the staging and production servers. While undeployment will make the database unaccessible the data remains unaffected and will be there for future deployments. Transfer releases ownership of the experiment to allow it to be built from an other GIT repository.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="validate"/>
<xs:enumeration value="debug"/>
<xs:enumeration value="draft"/>
<xs:enumeration value="staging"/>
<xs:enumeration value="production"/>
<xs:enumeration value="undeploy"/>
<xs:enumeration value="transfer"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
</xs:complexType>
<xs:complexType name="validationServiceType">
<xs:annotation>
<xs:documentation>Server side validation / registration services.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="validation" minOccurs="0" type="validationType"/>
</xs:sequence>
<xs:attribute name="stagingUrl" type="xs:string">
<xs:annotation>
<xs:documentation>The URL to an external staging registration service (for example to avoid cluttering the production validation service with mock data). When not specified the Frinex &lt;validation&gt; service is used.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="productionUrl" type="xs:string">
<xs:annotation>
<xs:documentation>The URL to an external production registration service (for example external participant validation or registration or similar service). When not specified the Frinex &lt;validation&gt; service is used.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="validationType">
<xs:annotation>
<xs:documentation>When metadata is sent to the server via transmitResults, this validation section defines the server side validation of metadata fields and optional restoring the value of metadata fields from the most recent validated record. Note that the intention of validation is not to authenticate, but to compare values in the admin system to client side equivalents such as an invitation code. Optionally metadata values in the admin system can be returned to the client to restore a session to the last stored values on a new device or browser. This section is not used when an external &lt;validationService&gt; is specified.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="recordMatch" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="postField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>The value of this metadatafield is sent to the admin server for validation.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adminField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>The value of the admin systems copy of this metadatafield is compared to the postField for validation.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="responseField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If validation succeeds then the matched value (of the postField and adminField) is returned to this metadata field. Usually this is the only way that this field is populated on the client.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If a record match error occurs the error message will be returned from the admin server in this metadatafield.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If a record match error occurs this is the error message that will be returned.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="validationRegex" type="xs:string">
<xs:annotation>
<xs:documentation>If provided then this regex is matched against the postField for validation.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="fieldMatch" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="postField" type="xs:string">
<xs:annotation>
<xs:documentation>If provided the value of the postField must match the value of the adminField for validation to succeed.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adminField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If validation succeeds then the value this metadatafield is returned.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="responseField" type="xs:string">
<xs:annotation>
<xs:documentation>If validation succeeds the response value is returned to the client in this metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If provided the value of the postField must match the value of the adminField then the error message will be returned in this metadatafield.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If provided the value of the postField does not match the value of the adminField then this message is returned.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="validationRegex" type="xs:string">
<xs:annotation>
<xs:documentation>If provided then this regex is matched against the value for validation.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="errorField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If a validation error occurs the error message will be returned from the admin server in this metadatafield.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>If no records match and a validation error occurs this is the error message that will be returned.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="allowValidationOnMissing" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>If there are no records for this user then if set to true the validation will succeed, if false then the user will need to be manually added into the admin system.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="administrationType">
<xs:annotation>
<xs:documentation>Administration</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="adminUser" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="name" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>For use with additional or external users a username for access to the administration system and JSON REST interface for this experiment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="dataAgreementField" minOccurs="0">
<xs:complexType>
<xs:attribute name="fieldName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="dataChannel" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="logToSdCard" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>Boolean</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="channel" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Integral Number</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="chart" minOccurs="0" maxOccurs="unbounded" type="adminChartType"/>
<xs:element name="dataTable" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="source" use="required">
<xs:annotation>
<xs:documentation>The source data for chart to be displayed in the table.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="stimulusResponse"/>
<xs:enumeration value="tagpair"/>
<xs:enumeration value="tagdata"/>
<xs:enumeration value="metadata"/>
<xs:enumeration value="timestamp"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
<xs:attribute name="columnNames" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="screenName" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this screenName will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="responseGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this responseGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="scoreGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this scoreGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stimulusId" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this stimulusId will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isCorrect">
<xs:annotation>
<xs:documentation>Only records matching this isCorrect value will be included for this dataset.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="True"/>
<xs:enumeration value="False"/>
<xs:enumeration value="Null"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this eventTag will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tagValue1" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this TagValue1 will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tagValue2" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this TagValue2 will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="allowDataDeletion" type="xs:boolean">
<xs:annotation>
<xs:documentation>Participant data cannot be deleted when this is omitted or false. Participant data can be deleted via the administration system when this is set to true.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="adminChartType">
<xs:annotation>
<xs:documentation>When present defines a chart that will be displayed on the main page of the experiment admin. Multiple charts can be used.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="metadata" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matching" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Only records matching this string will be counted for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="colour" type="rgbHexValue" use="required">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="tagData" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="screenName" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this screenName will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this eventTag will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tagValue" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this tagValue will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="colour" type="rgbHexValue" use="required">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:element name="stimulusResponse" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="screenName" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this screenName will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="responseGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this responseGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="scoreGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this scoreGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stimulusId" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this stimulusId will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isCorrect">
<xs:annotation>
<xs:documentation>Only records matching this isCorrect value will be included for this dataset.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="True"/>
<xs:enumeration value="False"/>
<xs:enumeration value="Null"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
<xs:attribute name="response" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this eventTag will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="colour" type="rgbHexValue" use="required">
<xs:annotation>
<xs:documentation>RGB Hex Value</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="type" use="required">
<xs:annotation>
<xs:documentation>The type of chart to be displayed.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="bar"/>
<xs:enumeration value="line"/>
<xs:enumeration value="pie"/>
<xs:enumeration value="bubble"/>
<xs:enumeration value="radar"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
</xs:complexType>
<xs:complexType name="dataTableType">
<xs:annotation>
<xs:documentation>When present defines a table that will be displayed on the main page of the experiment admin.</xs:documentation>
</xs:annotation>
<xs:attribute name="label" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="source" use="required">
<xs:annotation>
<xs:documentation>The source data for chart to be displayed in the table.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="stimulusResponse"/>
<xs:enumeration value="tagpair"/>
<xs:enumeration value="tagdata"/>
<xs:enumeration value="metadata"/>
<xs:enumeration value="timestamp"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
<xs:attribute name="columnNames" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="screenName" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this screenName will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="responseGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this responseGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="scoreGroup" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this scoreGroup will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="stimulusId" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this stimulusId will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="isCorrect">
<xs:annotation>
<xs:documentation>Only records matching this isCorrect value will be included for this dataset.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="True"/>
<xs:enumeration value="False"/>
<xs:enumeration value="Null"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this eventTag will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tagValue1" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this TagValue1 will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tagValue2" type="xs:string">
<xs:annotation>
<xs:documentation>Only records matching this TagValue2 will be included for this dataset. The percent sign will match zero, one, or multiple characters. The underscore will match any single character.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="metadataType">
<xs:annotation>
<xs:documentation>The fields of data to be collected for each participant and for use as storage data. The value of each field will be stored in the admin metadata table (participant listing). It is advisable to explicitly sendMetadata at relevant points in the experiment. If the URL used to access the experiment contains a GET parameter matching the postName of a metadata field, the value of the field will be set to the value of the provided GET parameter. This for example allows links to be distributed each of which determines the initial parameters as required for a given experiment.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="field" minOccurs="0" maxOccurs="unbounded" type="fieldType"/>
</xs:sequence>
</xs:complexType>
<xs:complexType name="fieldType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="controlledMessage" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="registrationField" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="controlledMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="controlledRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="postName" type="postName" use="required">
<xs:annotation>
<xs:documentation>An identifying name for each metadata field, also used in the column names of the admin system.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="registrationField" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="duplicatesControlledMessage" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="preventServerDuplicates" type="xs:boolean">
<xs:annotation>
<xs:documentation>Boolean</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="presenterType">
<xs:annotation>
<xs:documentation>Each screen in an experiment configuration is described in a PRESENTER element.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="title" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="menuLabel" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="presenterBaseTypeType" />
</xs:choice>
<xs:attribute name="self" type="presenterName">
<xs:annotation>
<xs:documentation>The name of the presenter, which must be unique per configuration file.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="title" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="menuLabel" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="back" type="presenterName">
<xs:annotation>
<xs:documentation>The value of this attribute must exist in one presenter self attributes. If the back attribute is provided the back button will be shown and it will cause the menu/title bar to be shown in the presenter even if it is otherwise hidden.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="next" type="presenterName">
<xs:annotation>
<xs:documentation>The value of this attribute must exist in one presenter self attributes. The value of this attribute is used as the target for gotoNextPresenter etc..</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="type">
<xs:annotation>
<xs:documentation>The type of presenter which also determines the features that can be used in the presenter.</xs:documentation>
</xs:annotation>
<xs:simpleType>
<xs:restriction>
<xs:simpleType>
<xs:list>
<xs:simpleType>
<xs:restriction base="xs:token">
<xs:enumeration value="transmission"/>
<xs:enumeration value="metadata"/>
<xs:enumeration value="preload"/>
<xs:enumeration value="stimulus"/>
<xs:enumeration value="colourPicker"/>
<xs:enumeration value="colourReport"/>
<xs:enumeration value="kindiagram"/>
<xs:enumeration value="menu"/>
<xs:enumeration value="debug"/>
<xs:enumeration value="text"/>
<xs:enumeration value="timeline"/>
</xs:restriction>
</xs:simpleType>
</xs:list>
</xs:simpleType>
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimuliType">
<xs:annotation>
<xs:documentation>All stimulus elements must be contained in the stimuli element.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="stimulus" minOccurs="0" maxOccurs="unbounded" type="stimulusType"/>
</xs:sequence>
</xs:complexType>
<xs:complexType name="stimulusType">
<xs:annotation>
<xs:documentation>Each individual stimulus can be described in the form of label, image, audio and video.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="label" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="code" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="identifier" type="stimulusIdentifier" use="required">
<xs:annotation>
<xs:documentation>An identifier for the stimulus consisting of three or more [a-Z0-9_] characters, which must be unique per configuration file.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="videoPath" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="imagePath" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="code" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="audioPath" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="label" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="correctResponses" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="tags" type="stimulusTags">
<xs:annotation>
<xs:documentation>Space separated list of stimulus tags [a-Z0-9]</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="pauseMs" type="xs:integer">
<xs:annotation>
<xs:documentation>Integral Number</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="htmlTextType">
<xs:annotation>
<xs:documentation>The contents of featureText will be shown as HTML and styled with styleName if provided</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="htmlTokenTextType">
<xs:annotation>
<xs:documentation>When the featureText contains string tokens they will be replaced with the relevant values, eg score values &lt;groupScore&gt; &lt;channelScore&gt; etc.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="evaluateTokenTextType">
<xs:annotation>
<xs:documentation>The value of evaluateTokens will have any string tokens replaced, followed by mathematical evaluation. The result be shown as HTML and styled with styleName if provided.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="logTokenTextType">
<xs:annotation>
<xs:documentation>Logs data to the tag pair data table. The value of dataLogFormat will have any string tokens replaced and stored in the TagValue2 column. When provided the value of type and headerKey will be stored in the EventTag	and TagValue1 columns respectively.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="type" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="headerKey" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataLogFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="plainTextType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="imageType">
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingType" />
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="menuItemType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="withStimuliType">
<xs:sequence>
<xs:group ref="sequenceOnceOrdered_eachStimulusType" />
<xs:element name="randomGrouping" minOccurs="0" type="randomGroupingType"/>
<xs:element name="stimuli" minOccurs="0" type="stimuliSelectType"/>
</xs:sequence>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatCount" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than zero the list will be repeated the selected items by the number of times specified without changing the order of the items. For example if repeat count was 3 then the result might be 321432143214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatRandomWindow" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than 0 all items will be randomised again after the repeatCount has been applied. This randomisation is constrained to the designated window of items causing the randomisation to be done in a moving window across all items. When used in conjunction with repeatCount this allows randomisation without adjacency at the boundary of repeats. For example, if a repeatCount of 3 resulted in 321432143214 a repeatRandomWindow of 2 could produce 231342413124 but cannot produce 214331322144. Whereas a repeatRandomWindow of 12 would randomise all items to any location and could produce 214331322144.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adjacencyThreshold" type="xs:integer">
<xs:annotation>
<xs:documentation>Sets a window of allowed proximity between stimuli that can be condisered the same. When greater than 0 the list of stimuli will be checked after randomisation for adjacency within the specified window and modified accordingly. If matching items are within the adjacency window, one of the items will be moved to a new position, in some cases a new position without an adjacent match will not be possible. The first attribute that has a value out of image, audio, video or label is used in the comparison. For example adjacencyThreshold 3 would disallow abcad and an attempt to rerandomise would follow. Defaults to 3 when not provided. </xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupStimuliType">
<xs:sequence>
<xs:group ref="sequenceOnceOrdered_groupStimulusType" />
<xs:element name="randomGrouping" minOccurs="0" type="randomGroupingType"/>
<xs:element name="stimuli" minOccurs="0" type="stimuliSelectType"/>
</xs:sequence>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatCount" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than zero the list will be repeated the selected items by the number of times specified without changing the order of the items. For example if repeat count was 3 then the result might be 321432143214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatRandomWindow" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than 0 all items will be randomised again after the repeatCount has been applied. This randomisation is constrained to the designated window of items causing the randomisation to be done in a moving window across all items. When used in conjunction with repeatCount this allows randomisation without adjacency at the boundary of repeats. For example, if a repeatCount of 3 resulted in 321432143214 a repeatRandomWindow of 2 could produce 231342413124 but cannot produce 214331322144. Whereas a repeatRandomWindow of 12 would randomise all items to any location and could produce 214331322144.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adjacencyThreshold" type="xs:integer">
<xs:annotation>
<xs:documentation>Sets a window of allowed proximity between stimuli that can be condisered the same. When greater than 0 the list of stimuli will be checked after randomisation for adjacency within the specified window and modified accordingly. If matching items are within the adjacency window, one of the items will be moved to a new position, in some cases a new position without an adjacent match will not be possible. The first attribute that has a value out of image, audio, video or label is used in the comparison. For example adjacencyThreshold 3 would disallow abcad and an attempt to rerandomise would follow. Defaults to 3 when not provided. </xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="loadStimulusType">
<xs:sequence>
<xs:group ref="sequenceOnceOrdered_hasMoreStimulusType" />
<xs:element name="randomGrouping" minOccurs="0" type="randomGroupingType"/>
<xs:element name="stimuli" minOccurs="0" type="stimuliSelectType"/>
</xs:sequence>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatCount" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than zero the list will be repeated the selected items by the number of times specified without changing the order of the items. For example if repeat count was 3 then the result might be 321432143214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatRandomWindow" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than 0 all items will be randomised again after the repeatCount has been applied. This randomisation is constrained to the designated window of items causing the randomisation to be done in a moving window across all items. When used in conjunction with repeatCount this allows randomisation without adjacency at the boundary of repeats. For example, if a repeatCount of 3 resulted in 321432143214 a repeatRandomWindow of 2 could produce 231342413124 but cannot produce 214331322144. Whereas a repeatRandomWindow of 12 would randomise all items to any location and could produce 214331322144.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adjacencyThreshold" type="xs:integer">
<xs:annotation>
<xs:documentation>Sets a window of allowed proximity between stimuli that can be condisered the same. When greater than 0 the list of stimuli will be checked after randomisation for adjacency within the specified window and modified accordingly. If matching items are within the adjacency window, one of the items will be moved to a new position, in some cases a new position without an adjacent match will not be possible. The first attribute that has a value out of image, audio, video or label is used in the comparison. For example adjacencyThreshold 3 would disallow abcad and an attempt to rerandomise would follow. Defaults to 3 when not provided. </xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="loadStimulusPluginType">
<xs:complexContent>
<xs:extension base="loadStimulusType">
<xs:attribute name="class" type="xs:string"/>
<xs:anyAttribute  processContents="lax"/>
</xs:extension>
</xs:complexContent>
</xs:complexType>
<xs:complexType name="withMatchingStimulusType">
<xs:group ref="sequenceOnceOrdered_hasMoreStimulusType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatCount" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than zero the list will be repeated the selected items by the number of times specified without changing the order of the items. For example if repeat count was 3 then the result might be 321432143214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatRandomWindow" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than 0 all items will be randomised again after the repeatCount has been applied. This randomisation is constrained to the designated window of items causing the randomisation to be done in a moving window across all items. When used in conjunction with repeatCount this allows randomisation without adjacency at the boundary of repeats. For example, if a repeatCount of 3 resulted in 321432143214 a repeatRandomWindow of 2 could produce 231342413124 but cannot produce 214331322144. Whereas a repeatRandomWindow of 12 would randomise all items to any location and could produce 214331322144.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="loadSdCardStimulusType">
<xs:sequence>
<xs:group ref="sequenceOnceOrdered_hasMoreStimulusType" />
<xs:element name="randomGrouping" minOccurs="0" type="randomGroupingType"/>
<xs:element name="stimuli" minOccurs="0" type="stimuliSelectType"/>
</xs:sequence>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="excludeRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="replacementRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatCount" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than zero the list will be repeated the selected items by the number of times specified without changing the order of the items. For example if repeat count was 3 then the result might be 321432143214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatRandomWindow" type="xs:integer">
<xs:annotation>
<xs:documentation>When greater than 0 all items will be randomised again after the repeatCount has been applied. This randomisation is constrained to the designated window of items causing the randomisation to be done in a moving window across all items. When used in conjunction with repeatCount this allows randomisation without adjacency at the boundary of repeats. For example, if a repeatCount of 3 resulted in 321432143214 a repeatRandomWindow of 2 could produce 231342413124 but cannot produce 214331322144. Whereas a repeatRandomWindow of 12 would randomise all items to any location and could produce 214331322144.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="adjacencyThreshold" type="xs:integer">
<xs:annotation>
<xs:documentation>Sets a window of allowed proximity between stimuli that can be condisered the same. When greater than 0 the list of stimuli will be checked after randomisation for adjacency within the specified window and modified accordingly. If matching items are within the adjacency window, one of the items will be moved to a new position, in some cases a new position without an adjacent match will not be possible. The first attribute that has a value out of image, audio, video or label is used in the comparison. For example adjacencyThreshold 3 would disallow abcad and an attempt to rerandomise would follow. Defaults to 3 when not provided. </xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="currentStimulusHasTagType">
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
<xs:attribute name="tags" type="stimulusTags" use="required">
<xs:annotation>
<xs:documentation>Space separated list of stimulus tags [a-Z0-9]</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="clearStimulusResponsesType">
<xs:annotation>
<xs:documentation>Clears all locally stored responses to all stimulus that have all the supplied tags. Stimuli that do not have ALL the provided tags will not be affected.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="tags" type="stimulusTags" use="required">
<xs:annotation>
<xs:documentation>Space separated list of stimulus tags [a-Z0-9]</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="validateStimuliResponsesType">
<xs:annotation>
<xs:documentation>Validates the current stimulus input that is visible in the presenter based on the validationRegex of each stimulus input if provided. Only when the stimulus input is enabled and visible will its validity be considered. After validation the stimulus response can be accessed via htmlTokenText and similar methods.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
</xs:complexType>
<xs:complexType name="stimulusExistsType">
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
<xs:attribute name="offset" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="showStimuliReportType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="sendStimuliReportType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="type" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="headerKey" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="separator" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="targetButtonType">
<xs:annotation>
<xs:documentation>Creates a button which when clicked navigates to the target presenter.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hotKeyInputType">
<xs:annotation>
<xs:documentation>Creates a key listener that will respond to keyboard or bluetooth button input. This input will not be visible but can be enabled or disabled with enableButtonGroup and disableButtonGroup. The behaviour of this feature will be to some degree platform dependant, for example the behaviour of key repeat and the certainty of onKeyUp being triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasKeyInputsConditionType" />
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="actionButtonType">
<xs:annotation>
<xs:documentation>Creates a button which when clicked evaluates the contents of its element.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="actionTokenButtonType">
<xs:annotation>
<xs:documentation>Creates a button where any tokens in its label, styleName and groupId are evaluated before displaying. When clicked evaluates the contents of its element.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="disableButtonGroupType">
<xs:annotation>
<xs:documentation>Disables any buttons with a groupId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="enableButtonGroupType">
<xs:annotation>
<xs:documentation>Enables any buttons with a groupId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hideButtonGroupType">
<xs:annotation>
<xs:documentation>Hides any buttons with a groupId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="styleButtonGroupType">
<xs:annotation>
<xs:documentation>Applies the provided style to any buttons with a groupId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="showButtonGroupType">
<xs:annotation>
<xs:documentation>Shows any buttons with a groupId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="requestFocusType">
<xs:annotation>
<xs:documentation>Requests focus to a single input specified by the matchingRegex if it exists and is visible. Only one input can have focus at a time so if multiple inputs match then the rest will be fail to gain focus.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgLoadGroupsType">
<xs:annotation>
<xs:documentation>Load compiled SVG data for use as image groups. Each group must be named in the SVG file.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_svgGroupsLoadedType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgGroupAddType">
<xs:annotation>
<xs:documentation>Appends the named section of the loaded SVG into the presenter.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="visible" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgSetLabelType">
<xs:annotation>
<xs:documentation>Sets the text value of the SVG text element matching groupId.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgGroupShowType">
<xs:annotation>
<xs:documentation>Sets the visibility of the section of SVG which must have already been added to the presenter.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="visible" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgGroupActionType">
<xs:annotation>
<xs:documentation>Sets a button action to the image group as specified in the loaded SVG data.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="svgGroupMatchingType">
<xs:annotation>
<xs:documentation>Sets the visibility of the matching child elements of the group which must have already been added to the presenter.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="visible" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusButtonType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusSliderType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="initial" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Initial value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="minimum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Minimum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="touchInputLabelButtonType">
<xs:annotation>
<xs:documentation>Creates touch input label button for use on tablets/mobile devices which responds to touch input from the participant.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="touchInputImageButtonType">
<xs:annotation>
<xs:documentation>Creates touch input image button for use on tablets/mobile devices which responds to touch input from the participant.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingButtonType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="touchInputVideoButtonType">
<xs:annotation>
<xs:documentation>Creates touch input video button for use on tablets/mobile devices which responds to touch input from the participant.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingButtonType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="loop" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the media playback will be set to play in a loop. When false the media will be set to play once then stop.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="touchInputCaptureType">
<xs:annotation>
<xs:documentation>Starts logging touch input of the participant.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_touchInputCaptureTypeType" />
<xs:attribute name="showControls" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="captureStartType">
<xs:annotation>
<xs:documentation>When the touch input capture has started the contents of this element will be evaluated.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_touchInputStartTypeType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="touchEndType">
<xs:annotation>
<xs:documentation>When the touch input capture anywhere on the screen has ended the contents of this element will be evaluated. If msToNext to next is provided then a gap of that ms time is permitted between touches without triggering the touchEnd.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="touchInputStopType">
<xs:annotation>
<xs:documentation>Stops the touch input capture and submits the logged touch input of the participant since touch input capture was started and then stops the input capture. This action is implicit but this feature allows the capture to be terminated early.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="ratingButtonType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="ratingRadioButtonType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="ratingCheckboxType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusFreeTextType">
<xs:annotation>
<xs:documentation>Adds a free text input for stimulus responses to be entered. If allowedCharCodes is provided then only those characters can be entered into the text box, if a disallowed character is entered then the inputErrorMessage will be shown. The stimulus response text is validated against the validationRegex which can also contain tokens such as &lt;stimulusCorrectResponses&gt;. If the stimulus response text does not match the validationRegex then the featureText message will be shown on validation. If a hotKey is provided and its value corresponds to the hotKey of a button in the presenter then that button will be activated by that key in the free text field. If the hotKey="ENTER" then the text input will be limited to a single line (because only one line can be entered without the enter key). When multiline input is allowed the validationRegex will need to match on all lines, so that any empty line does not fail the validation test. Matching all lines can be done with a validationRegex of [\\s\\S]{1,} where the 1 indicates the minimum input, alternatively [\\s\\S]* can be used if no minimum input is required.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="validationRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="allowedCharCodes" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="inputErrorMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusRatingButtonType">
<xs:annotation>
<xs:documentation>Adds rating buttons for the current stimulus based on the ratingLabels of the stimulus.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusRatingRadioType">
<xs:annotation>
<xs:documentation>Adds a radio button group for the current stimulus based on the ratingLabels of the stimulus.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusRatingCheckboxType">
<xs:annotation>
<xs:documentation>Adds a checkbox group for the current stimulus based on the ratingLabels of the stimulus.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="orientation" type="orientationType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusHasRatingOptionsType">
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
</xs:complexType>
<xs:complexType name="clearStimulusResponseType">
<xs:annotation>
<xs:documentation>Clears the locally stored response to the current stimulus. If groupId is provided then only the matching response group will be cleared, otherwise all responses for that stimulus are cleared.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusHasResponseType">
<xs:annotation>
<xs:documentation>When groupId is omitted conditionTrue will trigger if the current stimulus has any response. If groupId and matchingRegex are provided this will only trigger if a the current stimulus has a response in that group that matches the regex. If groupId contains tokens they will be replaced with the respective values before the evaluation.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="setStimulusCodeResponseType">
<xs:annotation>
<xs:documentation>Sets a response to the current stimulus with the value of codeFormat. The groupId determines the stimulus response group so that multiple responses can exist for each stimulus. If groupId or codeFormat contain tokens they will be replaced with the respective values.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="applyScore" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>If set to true then the stimulus response is compared to the stimulus correctResponses and a score is given accordingly.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addStimulusCodeResponseValidationType">
<xs:annotation>
<xs:documentation>Adds a stimulus validation listener for StimulusCodeResponses, so that they can be validated like other stimulus response types. The response is validated based on the matching of the validationRegex. If the validation fails the featureText will be shown to hint the user what is required. The groupId determines the stimulus response group so that multiple responses can exist for each stimulus. If groupId contain tokens they will be replaced with the respective values.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="validationRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="ratingFooterButtonType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabels" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelLeft" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="ratingLabelRight" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="targetFooterButtonType">
<xs:annotation>
<xs:documentation>Creates a button in the footer which when clicked navigates to the target presenter.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="actionFooterButtonType">
<xs:annotation>
<xs:documentation>Creates a button in the footer which when clicked evaluates the contents of its element.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addPaddingType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="localStorageDataType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to show the data stored in the local storage. Use with caution because there can be a lot of data.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="stimuliValidationType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to show the results of stimuli randomisation for each selection in the configuration file.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="addKeyboardDebugType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to show the keycodes entered by devices attached to the device. Such as bluetooth remotes or pointers.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="uploadUsersDataMenuType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to show a data upload menu for all participants that have data on the local device. The participant label on each button is determined by the fieldName attribute. Data for each participant will be automatically uploaded unless the dataAgreementField is set in the XML, in which case the data will be uploaded only if the agreement field matches the required value. If the participant data has been successfully sent to the server then a deletion button will be shown to remove the participant from the device. If there is an error writing to the local storage an error page will be shown that includes this menu.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addDebugWidgetsType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to enable debugging tools.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="allMetadataFieldsType">
<xs:annotation>
<xs:documentation>Adds an input for all metadata fields. Equivalent to metadataField for each field.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="metadataFieldType">
<xs:annotation>
<xs:documentation>Adds a single metadata field input. The type of input depends on the regex of the metadata field. A date input will be used if the regex is [0-3][0-9]/[0-1][0-9]/[1-2][0-9][0-9][0-9]. A checkbox will be used if the regex is true|false. A text area will be used (multiline) rather than a text box (single line) if the regex contains \\s. A select box will be used if the regex is a | separated list (except when { is used indicating a regular expression).</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusMetadataFieldType">
<xs:annotation>
<xs:documentation>Adds a metadata field input for the current stimulus. The user entered value will be stored in the stimulus data identifiable via the postName of the field.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="metadataFieldConnectionType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="linkedFieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a linked metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="oneToMany" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="metadataFieldVisibilityDependantType">
<xs:annotation>
<xs:documentation>Adds a metadata field input, the state of which is linked to the value of another input field. When value of the linked input field matches the visibleRegex this input field will be visible, otherwise it will be hidden. If the value of the linked input field matches the enabledRegex this input field will be enabled, otherwise it will be disabled to prevent input.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="linkedFieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a linked metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="visibleRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="enabledRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="metadataFieldDateTriggeredType">
<xs:annotation>
<xs:documentation>Adds a metadata field input, the value and state of which is linked to the value of a date input field. This field must be a selection list type and the selected item is determined by a corresponding item in the daysThresholds which is a list of values representing the days since the other field date. The intended use is to trigger the selection of the item index of this metadataField based on the calculated age in days from linkedFieldName. When value of the linked input field matches the visibleRegex this input field will be visible, otherwise it will be hidden. If the value of the linked input field matches the enabledRegex this input field will be enabled and the user can modify the selected value, otherwise it will be disabled to prevent the date assigned value being changed.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="linkedFieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a linked metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="daysThresholds" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="visibleRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="enabledRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="saveMetadataButtonType">
<xs:annotation>
<xs:documentation>Checks the currently displayed metadata fields for valid input. If there are errors the relevant field input is highlighted. If sendData is true then the metadata is sent to the admin system before proceeding and network errors will trigger an onError. If sendData is false onSuccess will be triggered if the metadata is valid regardless of network connectivity.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:sequence>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="sendData" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="networkErrorMessage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="createUserButtonType">
<xs:annotation>
<xs:documentation>Creates a button that when clicked creates a new user and then navigates to the target presenter as the new user.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="switchUserIdButtonType">
<xs:annotation>
<xs:documentation>Switch the user id to the value in the specified metadata field. The value of the field is first validated against the provided regex. Care should be used to make sure that the field contains a valid user id.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:sequence>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="validationRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="selectUserMenuType">
<xs:annotation>
<xs:documentation>Shows a menu listing the users in the system. The label on each menu item is determined by value of the provided metadata field. When a menu item is clicked the active user is changed and the next presenter is shown.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="selectLocaleMenuType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="eraseLocalStorageButtonType">
<xs:annotation>
<xs:documentation>For use in the debug type presenters to erase the local storage data. This action cannot be undone and if the local storage data has not be sent to the server or stored in the device storage, the data will be lost permanently.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="eraseUsersDataButtonType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="showCurrentMsType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="serverValueAssignType">
<xs:annotation>
<xs:documentation>Assigns a value from targetOptions based on the distribution data known by the server for the given presenter and puts the result into the metadata field identified by fieldName. Any value in the metadata field will be overwritten when valueOptions is supplied. However if the metadata field contains an item from targetOptions it will be unchanged and the server assigned counts will not be affected.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="targetOptions" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="serverValueCompleteType">
<xs:annotation>
<xs:documentation>Marks the server assigned value stored in the metadata field identified by fieldName as completed on the server. This will not change the value stored in the metadata field. If a new assignment is required then the metadata field would need to be manually cleared before requesting a new value via serverValueAssign. The completion of values will affect the distribution and therefore which values might be assigned next.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="cancelPauseTimersType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="cancelPauseAllType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="showStimulusProgressType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="displayCompletionCodeType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="generateCompletionCodeType">
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:complexType>
<xs:complexType name="sendAllDataType">
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:complexType>
<xs:complexType name="sendMetadataType">
<xs:annotation>
<xs:documentation>Sends the currently stored metadata field values to the admin system. For use in transmission type presenters.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:complexType>
<xs:complexType name="redirectToUrlType">
<xs:annotation>
<xs:documentation>Redirects the experiment to the URL specified in src. This feature cannot do error checking and therefore does not have onError or onSuccess because the experiment (calling page) has gone out scope by the time any error might occur.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="eraseLocalStorageOnWindowClosingType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="keepStimulusType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="removeMatchingStimulusType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="centrePageType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="clearPageType">
<xs:annotation>
<xs:documentation>Clears visual elements from the current presenter, stops timers and other listeners then submits any pending timestamps.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="backgroundImageType">
<xs:annotation>
<xs:documentation>Sets the background with the provided image.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="allMenuItemsType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="prevStimulusButtonType">
<xs:annotation>
<xs:documentation>Adds a button that when clicked decrements the current stimulus and triggers hasMoreStimulus. This button will not submit a stimulus response on its own. If however there is no previous stimuli then endOfStimulus will be triggered when the button is clicked.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatIncorrect" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="nextStimulusButtonType">
<xs:annotation>
<xs:documentation>Adds a button that when clicked increments the current stimulus and triggers hasMoreStimulus. This button will not submit a stimulus response on its own. If however there are no more stimuli then endOfStimulus will be triggered when the button is clicked.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatIncorrect" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="nextStimulusType">
<xs:annotation>
<xs:documentation>Increments the current stimulus and triggers hasMoreStimulus. This will not submit a stimulus response on its own. If however there are no more stimuli then endOfStimulus will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="repeatIncorrect" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="prevStimulusType">
<xs:annotation>
<xs:documentation>Decrements the current stimulus and triggers hasMoreStimulus. This will not submit a stimulus response on its own. If however there is no previous stimulus then endOfStimulus will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="repeatIncorrect" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="nextMatchingStimulusType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="addKinTypeGuiType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="diagramName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hasGetParameterType">
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
<xs:attribute name="parameterName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hasMetadataValueType">
<xs:annotation>
<xs:documentation>Replaces any token values in the matchingRegex then checks if the metadata field value matches the resulting regex. If the regex matches then coditionTrue is triggered otherwise conditionFalse is triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasTrueFalseConditionType" />
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="setMetadataValueType">
<xs:annotation>
<xs:documentation>The value of dataLogFormat will have any string tokens replaced. Next if the replacementRegex is provided then the regex is applied and only the values of the regex capture groups will be kept, otherwise the entire string is used. The result is then stored in the specified metadata field.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataLogFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="replacementRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="matchOnEvalTokensType">
<xs:annotation>
<xs:documentation>Compares the matchingRegex against the result of evaluateTokens after any metadata field tokens have been resolved, any arithmetic and boolean comparisons have been resolved.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasTrueFalseErrorConditionType" />
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="progressIndicatorType">
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="setMetadataEvalTokensType">
<xs:annotation>
<xs:documentation>The value of evaluateTokens will have any string tokens replaced, followed by mathematical evaluation. The resulting number is then stored in the specified metadata field.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="activateRandomItemType">
<xs:annotation>
<xs:documentation>Randomly activates one menu item on the current presenter providing that the target presenter has not already been completed. If all targets have been completed then the user will be sent to the next presenter as specified by the current presenter.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="gotoPresenterType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="gotoNextPresenterType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="logTimeStampType">
<xs:annotation>
<xs:documentation>Records a timestamp similar to the way image and media onLoad events etc. are logged. The logged ms is relative to the load time of the presenter.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="zeroStimulusStopwatchType">
<xs:annotation>
<xs:documentation>Each stimulus response can have a number of stimulus time periods recorded. At the point when the time period should start the named period should be zeroed. The stopwatch values are recorded in the stimulus response events for each stimulus based on the eventId attribute.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventId" type="postName">
<xs:annotation>
<xs:documentation>Event identifier.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stopStimulusStopwatchType">
<xs:annotation>
<xs:documentation>Each stimulus response can have a number of stimulus time periods recorded. At the point when the time period should end the named period should be stopped.  The stopwatch values are recorded in the stimulus response events for each stimulus based on the eventId attribute.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventId" type="postName">
<xs:annotation>
<xs:documentation>Event identifier.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hardwareTimeStampType">
<xs:annotation>
<xs:documentation>When the URL parameter &quot;hardwareTimeStamp&quot; is provided hardware measurable markers will be produced either visually on screen or as an audible tone or both. The visual markers are in the form of two black/white squares at the top of the screen. The audio markers are in the form of tones. These markers are equivalent to &lt;logTimeStamp&gt; and should be used in a similar way.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="opto1" type="booleanToggle">
<xs:annotation>
<xs:documentation>Sets the state of the on screen indicator for optical sensor one.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="opto2" type="booleanToggle">
<xs:annotation>
<xs:documentation>Sets the state of the on screen indicator for optical sensor two.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dtmf" type="dtmfType">
<xs:annotation>
<xs:documentation>Starts or stops the production of DTMF tones (dual-tone multi-frequency signaling) which can be used to encode some timing information in an audio output. The DTMF tone values can be decoded directly from the audio output or from subsequent audio recordings.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="recorderToneInjectionType">
<xs:annotation>
<xs:documentation>Injects an audible tone into the current recording stream (providing there is an active recording) for use as a timestamp when processing the resulting data. The audio marker is in the form a DTMF tone. A timestamp will also be stored in the database similar to that produced by &lt;logTimeStamp&gt;.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="dtmf" type="dtmfType">
<xs:annotation>
<xs:documentation>Starts or stops the production of DTMF tones (dual-tone multi-frequency signaling) which can be used to encode some timing information in an audio output. The DTMF tone values can be decoded directly from the audio output or from subsequent audio recordings.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="dtmfToneType">
<xs:annotation>
<xs:documentation>Produces the specified DTMF tone for the given time in milliseconds. When the milliseconds is set to 0 or omitted the tone will continue until it is stopped by setting the DTMF code to off.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dtmf" type="dtmfType">
<xs:annotation>
<xs:documentation>Starts or stops the production of DTMF tones (dual-tone multi-frequency signaling) which can be used to encode some timing information in an audio output. The DTMF tone values can be decoded directly from the audio output or from subsequent audio recordings.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="audioButtonType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="poster" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="preloadAllStimuliType">
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="tags" type="stimulusTags" use="required">
<xs:annotation>
<xs:documentation>Space separated list of stimulus tags [a-Z0-9]</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="showStimulusType">
<xs:annotation>
<xs:documentation>Repeats the current stimulus by triggering hasMoreStimulus. If there is no current stimulus then endOfStimulus will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="showStimulusGridType">
<xs:group ref="sequenceOnceOrdered_hasCorrectIncorrectType" />
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="columnCount" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="imageWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="animate" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="matchingStimulusGridType">
<xs:group ref="sequenceOnceOrdered_hasCorrectIncorrectType" />
<xs:attribute name="columnCount" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="animate" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="randomise" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the items will be randomised once before any repeats are calculated, when false the items will not be randomised. If the selected items were 1234, the result of randomise true might be 3214 for example.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="pauseType">
<xs:annotation>
<xs:documentation>Pause in milliseconds. When the time is up the contents of this element are evaluated. If tokens are required to calculate the ms value, an evaluatePause can be used.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="doLaterType">
<xs:annotation>
<xs:documentation>After the specified milliseconds have passed the contents of this element are evaluated. If tokens are required to calculate the ms value, an evaluatePause can be used.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="requestNotificationType">
<xs:annotation>
<xs:documentation>Request mobile notifications at given times in the future on Android and iOS apps. The presenters listed in targetOptions need to be comma separated and will be shown as buttons in the notification.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:sequence>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="targetOptions" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataLogFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="startTimerType">
<xs:annotation>
<xs:documentation>Starts a persistent timer which is identified by its listenerId. The start time is the moment the first startTimer for a given listenerId is encountered (this start time is recorded in the local storage data). This start time is persistent over page loads and navigation and can only be reset by a clearTimer followed by a startTimer. The content of the startTimer element is scoped to the presenter and will not trigger outside of the presenter that contains it. Each startTimer creates a callback that will trigger when the timer reaches the ms value, but will not trigger if that time has already passed while the presenter was not active. Multiple startTimer tags with the same listenerId can be used, each will share the same start moment allowing multiple events to be synchronised on one timer.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="compareTimerType">
<xs:annotation>
<xs:documentation>Compares the current time of a persistent timer that was started by startTimer with the same listenerId.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasThresholdType" />
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="clearTimerType">
<xs:annotation>
<xs:documentation>Clears the start time and terminates any pending events of any persistent timer matching listenerId (from the local storage data). After this a subsequent startTimer can be used to assign a new start time with this listenerId.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="logTimerValueType">
<xs:annotation>
<xs:documentation>Added a record in the admin system of the current milliseconds for a persistent timer which is identified by its listenerId.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="timerLabelType">
<xs:annotation>
<xs:documentation>Adds a label that shows the time value of listenerId minus msToNext and formats the result with msLabelFormat (similar to countdownLabel).</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msLabelFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="randomMsPauseType">
<xs:annotation>
<xs:documentation>Pause for a random number of milliseconds that is not less than minimum and not more than maximum. When the time is up the contents of this element are evaluated.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="minimum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Minimum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="evaluatePauseType">
<xs:annotation>
<xs:documentation>Pause based on the value of metadata, stimulus responses or scores etc. The value of evaluateTokens will have any string tokens replaced, followed by mathematical evaluation. The resulting number is the time of the pause in milliseconds. The evaluated value will be constrained so that it is within the minimum or maximum values. When the time is up the onSuccess element will be triggered. If there is an error evaluating the token string then onError will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="minimum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Minimum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addTimerTriggerType">
<xs:annotation>
<xs:documentation>Adds an onTimer action to the named persistent timer that will be triggered at the moment in ms defined in evaluateTokens. If the named persistent timer is not running it will be started. The persistent timer is identified by its listenerId based on the value of metadata, stimulus responses or scores etc. The value of evaluateTokens will have any string tokens replaced, followed by mathematical evaluation. The resulting number is the time in milliseconds at which the onTimer should occur. The evaluated value will be constrained so that it is within the minimum or maximum values. When the time is up the onTimer element will be triggered. If there is an error evaluating the token string then onError will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorTimerType" />
<xs:attribute name="minimum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Minimum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="startFrameRateTimerType">
<xs:annotation>
<xs:documentation>Starts a timer that evaluates its triggers before each frame is rendered in the browser. The resolution of these triggering events will be no less that the framerate, but the actual time resolution is browser dependant.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_hasFrameRateTriggersType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="addFrameTimeTriggerType">
<xs:annotation>
<xs:documentation>Adds a trigger to the containing frame timer. When the timer has a value equal or greater than the specified milliseconds this trigger. Only one trigger per millisecond value can be assigned. If the events is triggered later than the threshold value in milliseconds (20ms is the minimum recommended value) beyond the requested time the onError will be triggered and the framerate timer will stop processing further events.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorTimeCriticalType" />
<xs:attribute name="evaluateMs" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="threshold" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Threshold value.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addMediaTriggerType">
<xs:annotation>
<xs:documentation>Adds a media recording or playback event that will trigger when the media first passes the provided milliseconds value. The timing of this event will have a resolution not less than the length of the recording buffer. If the events is triggered later than the threshold value in milliseconds (20ms is the minimum recommended value) beyond the requested time the onError will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorTimeCriticalType" />
<xs:attribute name="evaluateMs" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="threshold" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Threshold value.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addRecorderDtmfTriggerType">
<xs:annotation>
<xs:documentation>Adds a web recorder event that will trigger when the provided DTMF tone is detected in the recorded audio stream. Only one trigger can be assigned per DTMF code.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:group ref="choiceAnyCount_isTimeCriticalType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="dtmf" type="dtmfType">
<xs:annotation>
<xs:documentation>Starts or stops the production of DTMF tones (dual-tone multi-frequency signaling) which can be used to encode some timing information in an audio output. The DTMF tone values can be decoded directly from the audio output or from subsequent audio recordings.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="addRecorderLevelTriggerType">
<xs:annotation>
<xs:documentation>Adds a web recorder event that will trigger when the a sound in the recorded audio stream exceeds the provided threshold above the ambient noise floor for greater than the provided milliseconds. If the levelIndicatorStyle is set then a recording threshold indicator will be shown. If levelIndicatorStyle is set and a region with the ID of AudioThresholdIndicator exists then that region will be used to position the recording threshold indicator.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:group ref="choiceAnyCount_isTimeCriticalType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="threshold" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Threshold value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="thresholdMs" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds required to reach the threshold.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="levelIndicatorStyle" type="xs:string">
<xs:annotation>
<xs:documentation>The CSS style name to use for the audio recording level indicator. When not present the audio level indicator will not be shown.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="triggerDefinitionType">
<xs:annotation>
<xs:documentation>The contents of this element will be activated when matched by the listenerId attribute of trigger or triggerRandom (for example). Based on the threshold and maximum values a trigger request does not always result in the trigger activating. The threshold is the number of activation requests before it will trigger. The maximum is the number of times the trigger can occur after which activation requests will be ignored. So a triggerDefinition with threshold 3 and maximum 1 would require three activation requests to trigger and it would not trigger again. A triggerDefinition can have more than one stimulus available (eg when it is in an eachStimulus or hasMoreStimulus). If this is the case then stimulus where triggerDefinition is defined will be used. If there is no stimulus where the triggerDefinition is defined then the stimulus from the point at which it is triggered will be used.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="threshold" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Threshold value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="habituationParadigmListenerType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="threshold" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Threshold value.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maximum" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Maximum value.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="triggerMatchingType">
<xs:annotation>
<xs:documentation>Trigger all triggerListeners matching the listenerId providing the threshold and maximum values are within the required values. The listenerId can contain tokens eg &lt;stimulusCode&gt;.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="triggerRandomType">
<xs:annotation>
<xs:documentation>Randomly trigger one any of the triggerListeners where the listenerId matches the matchingRegex and its maximum trigger count has not been reached. When there are no triggerListeners that match these criteria the child contents of tag will be triggered.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="matchingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Regular expression that will be used to determin a match.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="resetTriggerType">
<xs:annotation>
<xs:documentation>Reset the threshold and maximum counters for triggerListeners matching the listenerId.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="listenerId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="countdownLabelType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msLabelFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusPauseType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="stimulusLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="onTimeType">
<xs:group ref="choiceAnyCount_isTimeCriticalType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="onTimerType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="conditionTrueType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="conditionFalseType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="onSuccessType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="onActivateType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="kinTypeStringDiagramType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="kintypestring" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="loadKinTypeStringDiagramType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="diagramName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="editableKinEntitesDiagramType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="diagramName" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="onKeyUpType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="onKeyDownType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="responseCorrectType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="responseIncorrectType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupNetworkType">
<xs:annotation>
<xs:documentation>Connects a group of participants so that they can interact in a defined manner during the experiment. For each stimulus there is a number of phases which is determined by phasesPerStimulus.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_groupNetworkType" />
<xs:attribute name="groupMembers" type="groupMembers" use="required">
<xs:annotation>
<xs:documentation>List of members separated by , with preferably only a-Z being used for the member names.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupCommunicationChannels" type="groupChannels" use="required">
<xs:annotation>
<xs:documentation>List of communication channels separated by | for the group. The members are separated by , in each channel. Only members in the same channel will receive messages and these messages will only be from other members of the same channel.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="phasesPerStimulus" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The number of phases per round in the group. When current phase reaches this value the next stimulus will be triggered.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="hasMoreStimulusType">
<xs:group ref="choiceAnyCount_stimulusActionType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="beforeStimulusType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="eachStimulusType">
<xs:group ref="choiceAnyCount_stimulusActionType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="afterStimulusType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="endOfStimulusType">
<xs:annotation>
<xs:documentation>Will be triggered if there are zero stimuli loaded or when a nextStimulus/Button event occurs on the last stimulus.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="existingUserCheckType">
<xs:group ref="sequenceOnceOrdered_hasUserCountType" />
</xs:complexType>
<xs:complexType name="multipleUsersType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="singleUserType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="aboveThresholdType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="withinThresholdType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="mediaLoadedType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="mediaLoadFailedType">
<xs:annotation>
<xs:documentation>Will be triggered when the host system reports a failure. The timing of this depends on a few factors. If the network is unreachable it will fail quickly. Otherwise it will wait the timeout and probably some retry iterations. The timeout and retry parameters would differ per browser and probably are user configurable as well.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="mediaPlaybackStartedType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="mediaPlaybackCompleteType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="tableType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showOnBackButton" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the component will be invisible until the browser back button is clicked. Repeated clicks will toggle the visibility. The feature cannot be used in conjunction with a presenter back attribute.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="rowType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="columnType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionAppendType">
<xs:annotation>
<xs:documentation>Starts or resumes a region, allowing contents to be added to a given location in the presenter. If no region matching the regionId exists then a new region is created in the current location and then appended to. If a region of the same regionId already exists then it will be appended to.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionStyleType">
<xs:annotation>
<xs:documentation>If a region matching the regionId exists then it will have the style applied. If no matching region exists then nothing will be done.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionCodeStyleType">
<xs:annotation>
<xs:documentation>If a region matching the regionId exists then the styleName will have any tokens evaluated before the resulting style name is applied to the region. If no matching region exists then nothing will be done.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionReplaceType">
<xs:annotation>
<xs:documentation>If a region matching the regionId exists then it will cleared. If no region matching the regionId exists then a new region is created in the current location. The resulting region is then appended to.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionClearType">
<xs:annotation>
<xs:documentation>If a region matching the regionId exists then it will cleared. Unlike clearPage clearing a region only removes the visual components, so any media that has been placed in the region should be stopped first.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="regionDragDropType">
<xs:annotation>
<xs:documentation>If a region matching the regionId exists then the options of draggable and droppable will be applied making the region draggable or a drop target or both. The codeFormat of both the dragged item and the drop target will be set as the stimulus response for the drag action. If no matching region exists then nothing will be done.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_dragDropTypeType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="regionId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="draggable" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the item will be set as draggable. Will have no effect when false or not present.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="droptarget" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the item will be set as a drop target for drag actions. Will have no effect when false or not present.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="ondragstartType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="ondragoverType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="ondropType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="stimulusPresentType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="percentOfPage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxHeight" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="animate" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="replacementRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="replacement" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showControls" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusImageType">
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingType" />
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusCodeImageType">
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingType" />
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusCodeImageButtonType">
<xs:group ref="sequenceOnceOrdered_hasMediaLoadingButtonType" />
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusCodeVideoType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="maxHeight" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="percentOfPage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="loop" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the media playback will be set to play in a loop. When false the media will be set to play once then stop.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showControls" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusVideoType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="loop" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the media playback will be set to play in a loop. When false the media will be set to play once then stop.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showControls" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusCodeAudioType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="codeFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="showPlaybackIndicator" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusAudioType">
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="showPlaybackIndicator" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoPlay" type="xs:boolean" use="required">
<xs:annotation>
<xs:documentation>When true media will be played as soon as it has loaded. Modern web browsers will prevent media from playing before the user interacts with the page after each time it has loaded. If this is an issue, it can be overcome by always having a begin button, or by having a replay button in the case of an initial failure.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="playMediaType">
<xs:annotation>
<xs:documentation>Triggers play on any media with a mediaId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="loop" type="xs:boolean">
<xs:annotation>
<xs:documentation>When true the media playback will be set to play in a loop. When false the media will be set to play once then stop.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="rewindMediaType">
<xs:annotation>
<xs:documentation>Rewinds any media with a mediaId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="pauseMediaType">
<xs:annotation>
<xs:documentation>Triggers pause on any media with a mediaId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="logMediaTimeStampType">
<xs:annotation>
<xs:documentation>Logs a timestamp with the current time position for any media with a mediaId that matches the provided regex string.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimulusImageCaptureType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="percentOfPage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxHeight" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="msToNext" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>The milliseconds to delay after completion. The resulting delay is approximate and variability should be tested in the intended environment.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="VideoPanelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="percentOfPage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxHeight" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="poster" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="AnnotationTimelinePanelType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="src" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="poster" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="columnCount" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxStimuli" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="audioInputSelectWebType">
<xs:annotation>
<xs:documentation>Shows a select box of the available audio input devices for use with startAudioRecorderWeb. When an device is selected it will be used as the first preference when the next recording is made.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="deviceRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="startAudioRecorderWebType">
<xs:annotation>
<xs:documentation>Starts the HTML5 audio recorder which will send the recorded audio to the admin database. If downloadPermittedWindowMs is a positive number then the uploaded audio can be downloaded from the server for playback within that period of time for user verification, otherwise playback will not be possible. The onSuccess will be triggered when the recording has started. The onError will be triggered if the recorder cannot start. If the upload or playback fails then mediaLoadFailed will be triggered. Upload failure will also result in a subsequent upload attempt. When the recorded audio data has been submitted the mediaLoaded will be triggered even if playback is not enabled by downloadPermittedWindowMs, this allows upload verification before proceeding. The featureText is shown in the recording label. When the featureText is 00:00:00 the recording time will be shown in the recording label. When the featureText is &quot;hidden&quot; the recording label will not be shown (never record without explicit consent). The name of the audio input device used for the recording will be stored in the admin system. If the levelIndicatorStyle is set then a recording level indicator will be shown. If levelIndicatorStyle is set and a region with the ID of AudioRecorderWebLevelIndicator exists then that region will be used to position the recording level indicator. The recording indicator can be customised by redefining the .recordingLabel style, however it must be clear to the user that audio is being recorded, otherwise your mobile apps might get banned by iOS and PlayStore.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="sequenceOnceOrdered_hasMediaRecorderPlaybackType" />
</xs:sequence>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="downloadPermittedWindowMs" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>A time window in milliseconds within which download from the server will be allowed. When set to a non zero value the recording will be downloaded from the server ready for playback. So if playback of the recorded audio is not needed then this should be set to 0 to save bandwidth.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="deviceRegex" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="mediaId" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="recordingFormat" type="recordingFormatType">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="levelIndicatorStyle" type="xs:string">
<xs:annotation>
<xs:documentation>The CSS style name to use for the audio recording level indicator. When not present the audio level indicator will not be shown.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="echoCancellation" type="xs:boolean">
<xs:annotation>
<xs:documentation>When present this value will be passed on to web browser when the recording starts. Implementation is browser and platform specific.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="noiseSuppression" type="xs:boolean">
<xs:annotation>
<xs:documentation>When present this value will be passed on to web browser when the recording starts. Implementation is browser and platform specific.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="autoGainControl" type="xs:boolean">
<xs:annotation>
<xs:documentation>When present this value will be passed on to web browser when the recording starts. Implementation is browser and platform specific.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="startAudioRecorderAppType">
<xs:annotation>
<xs:documentation>Starts the Android wav recorder, the recorded wav files will be saved on the device in a sub directories based on value of the provided metadata field and the eventTag. The recording indicator can be customised by redefining the .recordingLabel style, however it must be clear to the user that audio is being recorded, otherwise your mobile apps might get banned by iOS and PlayStore.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="filePerStimulus" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="fieldName" type="postName" use="required">
<xs:annotation>
<xs:documentation>The postName used to identify a metadata field.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stopAudioRecorderType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="startAudioRecorderTagType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTier" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="endAudioRecorderTagType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTier" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="showHtmlPopupType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_hasActionButtonsType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="helpDialogueType">
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="closeButtonLabel" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="closeButtonLabel" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="userInfoType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="versionDataType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="showColourReportType">
<xs:group ref="sequenceOnceOrdered_hasThresholdType" />
<xs:attribute name="scoreThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupInitialisationErrorType">
<xs:annotation>
<xs:documentation>When the specified group already has enough members new members cannot be assigned to it or the member code has not been provided the contents of this element will be triggered. It is recommended that the paricipant is instructed here to request a new group which can be assigned in the URL along with the member code. Please note that a group and its members are rememberd on the server by design and reloading the page or clearing the browser storage will have no effect on group status.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupNetworkConnectingType">
<xs:annotation>
<xs:documentation>The first stage in setting up a group is connecting to the group server. The contents of this element will be triggered while this connection is being established.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupFindingMembersType">
<xs:annotation>
<xs:documentation>When the the connection to the group server is established the second stage is waiting for the other group members.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupNetworkSynchronisingType">
<xs:annotation>
<xs:documentation>For each stimulus change and phase change the group network needs to be synchronised. The contents of this element will be triggered while this synchronisation is being done.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupPhaseListenersType">
<xs:annotation>
<xs:documentation>The activities in the phase/participant matrix is defined here. Not all participants will see the same activity at the same time. It is possible for one, many or none to be triggered for any given phase member code combination.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_groupMemberActivityType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="groupMemberActivityType">
<xs:annotation>
<xs:documentation>Member activities will be triggered when the member code and the current phase coincide. This is determined by the phase matrix defined in each phaseMembers attribute.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_groupNetworkActionType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="phaseMembers" type="groupPhases" use="required">
<xs:annotation>
<xs:documentation>List of members for each phase. Each phase is separated by : and in each phase the matching members are separated by , when no members match a - is given for that phase.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupMemberCodeLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupMemberLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupMessageLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupResponseStimulusImageType">
<xs:annotation>
<xs:documentation>Displays the stimulus image that the last group message had responded with.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasMediaPlaybackType" />
<xs:attribute name="percentOfPage" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxHeight" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="maxWidth" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="animate" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupResponseFeedbackType">
<xs:annotation>
<xs:documentation>Compares the current stimulus to the last group response stimulus. If the group response stimulus equals the current group stimulus then it is considered to be correct.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasCorrectIncorrectType" />
</xs:complexType>
<xs:complexType name="groupScoreLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="groupChannelScoreLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="scoreLabelType">
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="submitGroupEventType">
<xs:annotation>
<xs:documentation>Submits a record of the current group state from the perspective of the current group member to the admin database.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="sendGroupMessageButtonType">
<xs:annotation>
<xs:documentation>Adds a button that will send a message to the group members that are in the current member's communication channel. The message content is the concatenated values of all freetext inputs currently in the presenter. If any freetext input is not valid then the relevant freetext input will show an error and the message will not be sent.</xs:documentation>
</xs:annotation>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="translation" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:attribute name="locale" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="featureText" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
</xs:element>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
</xs:choice>
<xs:attribute name="featureText" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>Text that will be visible to the user.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="hotKey" type="hotKeyType">
<xs:annotation>
<xs:documentation>Option List</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="repeatIncorrect" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="incrementPhase" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Increments the current group phase and triggers the relevant group activities for all members of the group.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="styleName" type="xs:string">
<xs:annotation>
<xs:documentation>One or more CSS stylenames to apply to the feature. These can be the built in styles or custom styles defined in the SCSS section.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="sendGroupMessageType">
<xs:annotation>
<xs:documentation>Sends a message to the group members that are in the current member's communication channel. The contents of the message is the last message received in the current users communication channel.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="incrementPhase" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Increments the current group phase and triggers the relevant group activities for all members of the group.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="sendGroupStoredMessageType">
<xs:annotation>
<xs:documentation>Sends a message to the group members that are in the current member's communication channel. The message is the stored value of groupId for current stimulus. If groupId is not provided 'groupMessage' will be used. If the is no stored value then an empty message will be sent.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="incrementPhase" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Increments the current group phase and triggers the relevant group activities for all members of the group.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="groupId" type="xs:string">
<xs:annotation>
<xs:documentation>This value is used in multiple ways depending on the context, to set the button group name used to enable and disable button groups, to assign the storage name for stimulus responses and the field name in the JSON data transmitted to the admin server so that multiple responses can be collected for a single stimulus.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="streamGroupCanvasType">
<xs:annotation>
<xs:documentation>Creates a canvas that is streamed to other members of the group based on the stream communication channels. The stream is terminated when the containing region or page is cleared or when the group network ends.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="streamChannels" type="groupChannels" use="required">
<xs:annotation>
<xs:documentation>List of directional communication channels separated by | for the given streaming media. The members are separated by , in each channel. Only the first member in each channel will transmit into the stream while the remaining members in each channel will receive the stream.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="streamGroupCameraType">
<xs:annotation>
<xs:documentation>Shares a camera stream to other members of the group based on the stream communication channels. The stream is terminated when the containing region or page is cleared or when the group network ends.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="streamChannels" type="groupChannels" use="required">
<xs:annotation>
<xs:documentation>List of directional communication channels separated by | for the given streaming media. The members are separated by , in each channel. Only the first member in each channel will transmit into the stream while the remaining members in each channel will receive the stream.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="sendGroupTokenMessageType">
<xs:annotation>
<xs:documentation>Sends a message to the group members that are in the current member's communication channel. The contents of the message is the value of dataLogFormat after any string tokens have been replaced.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="eventTag" type="xs:string">
<xs:annotation>
<xs:documentation>When present this tag will be logged in the timestamps table as close as possible to the moment the event occurs.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="incrementPhase" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>Increments the current group phase and triggers the relevant group activities for all members of the group.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataLogFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="clearCurrentScoreType">
<xs:annotation>
<xs:documentation>Clears the current score and sets the current score group string based on the evaluateTokens. The score group is a marker shown in the admin system to keep track of the records and does not affect the score collection process.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="evaluateTokens" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="scoreIncrementType">
<xs:annotation>
<xs:documentation>Applies the provided score. When the value is positive, both the score and potential are incremented by the value and any correct streak is maintained. When the score is negative only the potential is incremented by the value and any incorrect streak is maintained. When the score is zero no change is made to either the score or potential, however both the correct and incorrect streaks are cleared.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="dataChannel" type="xs:integer">
<xs:annotation>
<xs:documentation></xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="scoreValue" type="xs:integer" use="required">
<xs:annotation>
<xs:documentation>A positive number for achievements or a negative number for failures or zero for neither.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="bestScoreAboveThresholdType">
<xs:group ref="sequenceOnceOrdered_hasThresholdType" />
<xs:attribute name="scoreThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="potentialThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="correctStreak" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorStreak" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="gamesPlayed" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="totalScoreAboveThresholdType">
<xs:group ref="sequenceOnceOrdered_hasThresholdType" />
<xs:attribute name="scoreThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="potentialThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="gamesPlayed" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="scoreAboveThresholdType">
<xs:group ref="sequenceOnceOrdered_hasThresholdType" />
<xs:attribute name="scoreThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="potentialThreshold" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="correctStreak" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="errorStreak" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="gamesPlayed" type="xs:string">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="resetStimulusType">
<xs:annotation>
<xs:documentation>Clears the presenter's selected stimulus and the list of stimulus that have been seen so that the presenter can select a fresh list of stimuli.</xs:documentation>
</xs:annotation>
<xs:group ref="choiceAnyCount_noneType" minOccurs="0" maxOccurs="unbounded"/>
<xs:attribute name="target" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="submitTestResultsType">
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:complexType>
<xs:complexType name="validateMetadataType">
<xs:annotation>
<xs:documentation>Validates the current user id and the metadata fields (as listed in the validationService section of the experiment configuration file) to the to the Frinex admin (unless another endpoint is defined in the stagingUrl and productionUrl of the validationService), the corresponding return metadata fields from this validationService section will be updated locally from the values previously saved in the admin system.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
</xs:complexType>
<xs:complexType name="transmitResultsType">
<xs:annotation>
<xs:documentation>Transmits the values of the metadata fields that match the sendingRegex to the endpoint defined in stagingUrl and productionUrl of the validationService. Any metadata fields returned from that service which match the sendingRegex will be updated if there is such a field. If the connection to the registration service returns a 200 response then onSuccess is triggered. Depending on the validation service an onSuccess might only indicate a network success and does not always indicate a validated state from the validation service, you will also need to check the receiving fields. If there is a network error or the registration service returns a non 200 response then onError will be triggered. One and only one of either onError or onSuccess will always be triggered, however the time required to trigger will depend on network conditions.</xs:documentation>
</xs:annotation>
<xs:group ref="sequenceOnceOrdered_hasErrorSuccessType" />
<xs:attribute name="receivingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="sendingRegex" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="dataLogFormat" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>String</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="onErrorType">
<xs:group ref="choiceAnyCount_anyType" minOccurs="0" maxOccurs="unbounded"/>
</xs:complexType>
<xs:complexType name="randomGroupingType">
<xs:annotation>
<xs:documentation>List of stimuli tag names one of which will be randomly selected, unless the selection has been predetermined by a metadata field value or by URL GET parameters.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="tag" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:simpleContent>
<xs:extension base="xs:string">
<xs:attribute name="alias" type="xs:string">
<xs:annotation>
<xs:documentation>This tag will be used when the contents of the storageField matches the value of alias.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:extension>
</xs:simpleContent>
</xs:complexType>
</xs:element>
<xs:element name="list" minOccurs="0" maxOccurs="unbounded">
<xs:complexType>
<xs:simpleContent>
<xs:extension base="xs:string">
<xs:attribute name="alias" type="xs:string" use="required">
<xs:annotation>
<xs:documentation>This list will be used when the contents of the storageField matches the value of alias. For example storageField=&quot;selectList&quot; and alias=&quot;s6&quot; would match with GET parameter selectList=s6 in the URL.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:extension>
</xs:simpleContent>
</xs:complexType>
</xs:element>
</xs:sequence>
<xs:attribute name="storageField" type="xs:string">
<xs:annotation>
<xs:documentation>If this metadata field contains one of the tags or alias, it will be used. Otherwise a random tag is selected for use, it is then stored in this metadata field. This allows a stimuli selection process to carry over between presenters.</xs:documentation>
</xs:annotation>
</xs:attribute>
<xs:attribute name="consumedTagGroup" type="xs:string">
<xs:annotation>
<xs:documentation>When a tag is selected for use, it is put into this named list and will not be selected again, providing this named list is used. This allows a stimuli selection process to carry over between presenters.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:complexType name="stimuliSelectType">
<xs:annotation>
<xs:documentation>List of stimuli tag names which determine which stimuli are selected. All stimuli which contain any of the tags will be included in the list of stimuli. The number of selected stimuli will be limited to the maximum that has been requested. The stimuli selected by these tags will always be selected even if a randomGrouping is used.</xs:documentation>
</xs:annotation>
<xs:sequence>
<xs:element name="tag" minOccurs="0" maxOccurs="unbounded" type="xs:string"/>
</xs:sequence>
<xs:attribute name="idListField" type="xs:string">
<xs:annotation>
<xs:documentation>When provided this metadata field must contain a list of stimuli IDs separated by commas which will then be used in the stimuli selection process. This allows stimuli lists to be generated and stored between presenters.</xs:documentation>
</xs:annotation>
</xs:attribute>
</xs:complexType>
<xs:group name="sequenceOnceOrdered_hasKeyInputsConditionType">
<xs:sequence>
<xs:element name="onKeyUp" type="onKeyUpType"/>
<xs:element name="onKeyDown" type="onKeyDownType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasErrorTimeCriticalType">
<xs:sequence>
<xs:element name="onTime" type="onTimeType"/>
<xs:element name="onError" type="onErrorType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_groupNetworkActionType">
<xs:choice>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="withMatchingStimulus" type="withMatchingStimulusType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="currentStimulusHasTag" type="currentStimulusHasTagType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="validateStimuliResponses" type="validateStimuliResponsesType"/>
<xs:element name="stimulusExists" type="stimulusExistsType"/>
<xs:element name="showStimuliReport" type="showStimuliReportType"/>
<xs:element name="sendStimuliReport" type="sendStimuliReportType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="stimulusButton" type="stimulusButtonType"/>
<xs:element name="stimulusSlider" type="stimulusSliderType"/>
<xs:element name="touchInputCapture" type="touchInputCaptureType"/>
<xs:element name="ratingButton" type="ratingButtonType"/>
<xs:element name="ratingRadioButton" type="ratingRadioButtonType"/>
<xs:element name="ratingCheckbox" type="ratingCheckboxType"/>
<xs:element name="stimulusFreeText" type="stimulusFreeTextType"/>
<xs:element name="stimulusRatingButton" type="stimulusRatingButtonType"/>
<xs:element name="stimulusRatingRadio" type="stimulusRatingRadioType"/>
<xs:element name="stimulusRatingCheckbox" type="stimulusRatingCheckboxType"/>
<xs:element name="stimulusHasRatingOptions" type="stimulusHasRatingOptionsType"/>
<xs:element name="clearStimulusResponse" type="clearStimulusResponseType"/>
<xs:element name="stimulusHasResponse" type="stimulusHasResponseType"/>
<xs:element name="setStimulusCodeResponse" type="setStimulusCodeResponseType"/>
<xs:element name="addStimulusCodeResponseValidation" type="addStimulusCodeResponseValidationType"/>
<xs:element name="ratingFooterButton" type="ratingFooterButtonType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="stimulusMetadataField" type="stimulusMetadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="showStimulusProgress" type="showStimulusProgressType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="keepStimulus" type="keepStimulusType"/>
<xs:element name="removeMatchingStimulus" type="removeMatchingStimulusType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="prevStimulusButton" type="prevStimulusButtonType"/>
<xs:element name="nextStimulusButton" type="nextStimulusButtonType"/>
<xs:element name="nextStimulus" type="nextStimulusType"/>
<xs:element name="prevStimulus" type="prevStimulusType"/>
<xs:element name="nextMatchingStimulus" type="nextMatchingStimulusType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="showStimulus" type="showStimulusType"/>
<xs:element name="showStimulusGrid" type="showStimulusGridType"/>
<xs:element name="matchingStimulusGrid" type="matchingStimulusGridType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="stimulusPause" type="stimulusPauseType"/>
<xs:element name="stimulusLabel" type="stimulusLabelType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="regionCodeStyle" type="regionCodeStyleType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="regionDragDrop" type="regionDragDropType"/>
<xs:element name="stimulusPresent" type="stimulusPresentType"/>
<xs:element name="stimulusImage" type="stimulusImageType"/>
<xs:element name="stimulusCodeImage" type="stimulusCodeImageType"/>
<xs:element name="stimulusCodeImageButton" type="stimulusCodeImageButtonType"/>
<xs:element name="stimulusCodeVideo" type="stimulusCodeVideoType"/>
<xs:element name="stimulusVideo" type="stimulusVideoType"/>
<xs:element name="stimulusCodeAudio" type="stimulusCodeAudioType"/>
<xs:element name="stimulusAudio" type="stimulusAudioType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="stimulusImageCapture" type="stimulusImageCaptureType"/>
<xs:element name="VideoPanel" type="VideoPanelType"/>
<xs:element name="AnnotationTimelinePanel" type="AnnotationTimelinePanelType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="startAudioRecorderWeb" type="startAudioRecorderWebType"/>
<xs:element name="startAudioRecorderApp" type="startAudioRecorderAppType"/>
<xs:element name="stopAudioRecorder" type="stopAudioRecorderType"/>
<xs:element name="startAudioRecorderTag" type="startAudioRecorderTagType"/>
<xs:element name="endAudioRecorderTag" type="endAudioRecorderTagType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="groupMemberCodeLabel" type="groupMemberCodeLabelType"/>
<xs:element name="groupMemberLabel" type="groupMemberLabelType"/>
<xs:element name="groupMessageLabel" type="groupMessageLabelType"/>
<xs:element name="groupResponseStimulusImage" type="groupResponseStimulusImageType"/>
<xs:element name="groupResponseFeedback" type="groupResponseFeedbackType"/>
<xs:element name="groupScoreLabel" type="groupScoreLabelType"/>
<xs:element name="groupChannelScoreLabel" type="groupChannelScoreLabelType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="submitGroupEvent" type="submitGroupEventType"/>
<xs:element name="sendGroupMessageButton" type="sendGroupMessageButtonType"/>
<xs:element name="sendGroupMessage" type="sendGroupMessageType"/>
<xs:element name="sendGroupStoredMessage" type="sendGroupStoredMessageType"/>
<xs:element name="streamGroupCanvas" type="streamGroupCanvasType"/>
<xs:element name="streamGroupCamera" type="streamGroupCameraType"/>
<xs:element name="sendGroupTokenMessage" type="sendGroupTokenMessageType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasUserCountType">
<xs:sequence>
<xs:element name="multipleUsers" type="multipleUsersType"/>
<xs:element name="singleUser" type="singleUserType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_touchInputCaptureTypeType">
<xs:sequence>
<xs:element name="captureStart" type="captureStartType"/>
<xs:element name="touchEnd" type="touchEndType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_dragDropTypeType">
<xs:choice>
<xs:element name="ondragstart" type="ondragstartType"/>
<xs:element name="ondragover" type="ondragoverType"/>
<xs:element name="ondrop" type="ondropType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_groupStimulusType">
<xs:sequence>
<xs:element name="groupNetwork" type="groupNetworkType"/>
<xs:element name="endOfStimulus" type="endOfStimulusType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_noneType">
<xs:choice>
</xs:choice>
</xs:group>
<xs:group name="choiceAnyCount_hasActionButtonsType">
<xs:choice>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
</xs:choice>
</xs:group>
<xs:group name="presenterBaseTypeType">
<xs:choice>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasMediaRecorderPlaybackType">
<xs:sequence>
<xs:element name="onSuccess" type="onSuccessType"/>
<xs:element name="onError" type="onErrorType"/>
<xs:element name="mediaLoaded" type="mediaLoadedType"/>
<xs:element name="mediaLoadFailed" type="mediaLoadFailedType"/>
<xs:element name="mediaPlaybackStarted" type="mediaPlaybackStartedType"/>
<xs:element name="mediaPlaybackComplete" type="mediaPlaybackCompleteType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_groupNetworkType">
<xs:sequence>
<xs:element name="groupInitialisationError" type="groupInitialisationErrorType"/>
<xs:element name="groupNetworkConnecting" type="groupNetworkConnectingType"/>
<xs:element name="groupFindingMembers" type="groupFindingMembersType"/>
<xs:element name="groupNetworkSynchronising" type="groupNetworkSynchronisingType"/>
<xs:element name="groupPhaseListeners" type="groupPhaseListenersType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasMoreStimulusType">
<xs:sequence>
<xs:element name="hasMoreStimulus" type="hasMoreStimulusType"/>
<xs:element name="endOfStimulus" type="endOfStimulusType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_svgGroupsLoadedType">
<xs:choice>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="svgGroupAdd" type="svgGroupAddType"/>
<xs:element name="svgSetLabel" type="svgSetLabelType"/>
<xs:element name="svgGroupShow" type="svgGroupShowType"/>
<xs:element name="svgGroupAction" type="svgGroupActionType"/>
<xs:element name="svgGroupMatching" type="svgGroupMatchingType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasErrorTimerType">
<xs:sequence>
<xs:element name="onTimer" type="onTimerType"/>
<xs:element name="onError" type="onErrorType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_stimulusActionType">
<xs:choice>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="withMatchingStimulus" type="withMatchingStimulusType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="currentStimulusHasTag" type="currentStimulusHasTagType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="validateStimuliResponses" type="validateStimuliResponsesType"/>
<xs:element name="stimulusExists" type="stimulusExistsType"/>
<xs:element name="showStimuliReport" type="showStimuliReportType"/>
<xs:element name="sendStimuliReport" type="sendStimuliReportType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="stimulusButton" type="stimulusButtonType"/>
<xs:element name="stimulusSlider" type="stimulusSliderType"/>
<xs:element name="touchInputCapture" type="touchInputCaptureType"/>
<xs:element name="ratingButton" type="ratingButtonType"/>
<xs:element name="ratingRadioButton" type="ratingRadioButtonType"/>
<xs:element name="ratingCheckbox" type="ratingCheckboxType"/>
<xs:element name="stimulusFreeText" type="stimulusFreeTextType"/>
<xs:element name="stimulusRatingButton" type="stimulusRatingButtonType"/>
<xs:element name="stimulusRatingRadio" type="stimulusRatingRadioType"/>
<xs:element name="stimulusRatingCheckbox" type="stimulusRatingCheckboxType"/>
<xs:element name="stimulusHasRatingOptions" type="stimulusHasRatingOptionsType"/>
<xs:element name="clearStimulusResponse" type="clearStimulusResponseType"/>
<xs:element name="stimulusHasResponse" type="stimulusHasResponseType"/>
<xs:element name="setStimulusCodeResponse" type="setStimulusCodeResponseType"/>
<xs:element name="addStimulusCodeResponseValidation" type="addStimulusCodeResponseValidationType"/>
<xs:element name="ratingFooterButton" type="ratingFooterButtonType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="stimulusMetadataField" type="stimulusMetadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="showStimulusProgress" type="showStimulusProgressType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="keepStimulus" type="keepStimulusType"/>
<xs:element name="removeMatchingStimulus" type="removeMatchingStimulusType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="prevStimulusButton" type="prevStimulusButtonType"/>
<xs:element name="nextStimulusButton" type="nextStimulusButtonType"/>
<xs:element name="nextStimulus" type="nextStimulusType"/>
<xs:element name="prevStimulus" type="prevStimulusType"/>
<xs:element name="nextMatchingStimulus" type="nextMatchingStimulusType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="showStimulus" type="showStimulusType"/>
<xs:element name="showStimulusGrid" type="showStimulusGridType"/>
<xs:element name="matchingStimulusGrid" type="matchingStimulusGridType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="stimulusPause" type="stimulusPauseType"/>
<xs:element name="stimulusLabel" type="stimulusLabelType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="regionCodeStyle" type="regionCodeStyleType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="regionDragDrop" type="regionDragDropType"/>
<xs:element name="stimulusPresent" type="stimulusPresentType"/>
<xs:element name="stimulusImage" type="stimulusImageType"/>
<xs:element name="stimulusCodeImage" type="stimulusCodeImageType"/>
<xs:element name="stimulusCodeImageButton" type="stimulusCodeImageButtonType"/>
<xs:element name="stimulusCodeVideo" type="stimulusCodeVideoType"/>
<xs:element name="stimulusVideo" type="stimulusVideoType"/>
<xs:element name="stimulusCodeAudio" type="stimulusCodeAudioType"/>
<xs:element name="stimulusAudio" type="stimulusAudioType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="stimulusImageCapture" type="stimulusImageCaptureType"/>
<xs:element name="VideoPanel" type="VideoPanelType"/>
<xs:element name="AnnotationTimelinePanel" type="AnnotationTimelinePanelType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="startAudioRecorderWeb" type="startAudioRecorderWebType"/>
<xs:element name="startAudioRecorderApp" type="startAudioRecorderAppType"/>
<xs:element name="stopAudioRecorder" type="stopAudioRecorderType"/>
<xs:element name="startAudioRecorderTag" type="startAudioRecorderTagType"/>
<xs:element name="endAudioRecorderTag" type="endAudioRecorderTagType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="groupMemberCodeLabel" type="groupMemberCodeLabelType"/>
<xs:element name="groupMemberLabel" type="groupMemberLabelType"/>
<xs:element name="groupMessageLabel" type="groupMessageLabelType"/>
<xs:element name="groupResponseStimulusImage" type="groupResponseStimulusImageType"/>
<xs:element name="groupResponseFeedback" type="groupResponseFeedbackType"/>
<xs:element name="groupScoreLabel" type="groupScoreLabelType"/>
<xs:element name="groupChannelScoreLabel" type="groupChannelScoreLabelType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="submitGroupEvent" type="submitGroupEventType"/>
<xs:element name="sendGroupMessageButton" type="sendGroupMessageButtonType"/>
<xs:element name="sendGroupMessage" type="sendGroupMessageType"/>
<xs:element name="sendGroupStoredMessage" type="sendGroupStoredMessageType"/>
<xs:element name="streamGroupCanvas" type="streamGroupCanvasType"/>
<xs:element name="streamGroupCamera" type="streamGroupCameraType"/>
<xs:element name="sendGroupTokenMessage" type="sendGroupTokenMessageType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasMediaLoadingType">
<xs:sequence>
<xs:element name="mediaLoaded" type="mediaLoadedType"/>
<xs:element name="mediaLoadFailed" type="mediaLoadFailedType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_eachStimulusType">
<xs:sequence>
<xs:element name="beforeStimulus" type="beforeStimulusType"/>
<xs:element name="eachStimulus" type="eachStimulusType"/>
<xs:element name="afterStimulus" type="afterStimulusType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasCorrectIncorrectType">
<xs:sequence>
<xs:element name="responseCorrect" type="responseCorrectType"/>
<xs:element name="responseIncorrect" type="responseIncorrectType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_anyType">
<xs:choice>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="withMatchingStimulus" type="withMatchingStimulusType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="currentStimulusHasTag" type="currentStimulusHasTagType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="validateStimuliResponses" type="validateStimuliResponsesType"/>
<xs:element name="stimulusExists" type="stimulusExistsType"/>
<xs:element name="showStimuliReport" type="showStimuliReportType"/>
<xs:element name="sendStimuliReport" type="sendStimuliReportType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="svgGroupAdd" type="svgGroupAddType"/>
<xs:element name="svgSetLabel" type="svgSetLabelType"/>
<xs:element name="svgGroupShow" type="svgGroupShowType"/>
<xs:element name="svgGroupAction" type="svgGroupActionType"/>
<xs:element name="svgGroupMatching" type="svgGroupMatchingType"/>
<xs:element name="stimulusButton" type="stimulusButtonType"/>
<xs:element name="stimulusSlider" type="stimulusSliderType"/>
<xs:element name="touchInputLabelButton" type="touchInputLabelButtonType"/>
<xs:element name="touchInputImageButton" type="touchInputImageButtonType"/>
<xs:element name="touchInputVideoButton" type="touchInputVideoButtonType"/>
<xs:element name="touchInputCapture" type="touchInputCaptureType"/>
<xs:element name="touchInputStop" type="touchInputStopType"/>
<xs:element name="ratingButton" type="ratingButtonType"/>
<xs:element name="ratingRadioButton" type="ratingRadioButtonType"/>
<xs:element name="ratingCheckbox" type="ratingCheckboxType"/>
<xs:element name="stimulusFreeText" type="stimulusFreeTextType"/>
<xs:element name="stimulusRatingButton" type="stimulusRatingButtonType"/>
<xs:element name="stimulusRatingRadio" type="stimulusRatingRadioType"/>
<xs:element name="stimulusRatingCheckbox" type="stimulusRatingCheckboxType"/>
<xs:element name="stimulusHasRatingOptions" type="stimulusHasRatingOptionsType"/>
<xs:element name="clearStimulusResponse" type="clearStimulusResponseType"/>
<xs:element name="stimulusHasResponse" type="stimulusHasResponseType"/>
<xs:element name="setStimulusCodeResponse" type="setStimulusCodeResponseType"/>
<xs:element name="addStimulusCodeResponseValidation" type="addStimulusCodeResponseValidationType"/>
<xs:element name="ratingFooterButton" type="ratingFooterButtonType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="stimulusMetadataField" type="stimulusMetadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="showStimulusProgress" type="showStimulusProgressType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="keepStimulus" type="keepStimulusType"/>
<xs:element name="removeMatchingStimulus" type="removeMatchingStimulusType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="prevStimulusButton" type="prevStimulusButtonType"/>
<xs:element name="nextStimulusButton" type="nextStimulusButtonType"/>
<xs:element name="nextStimulus" type="nextStimulusType"/>
<xs:element name="prevStimulus" type="prevStimulusType"/>
<xs:element name="nextMatchingStimulus" type="nextMatchingStimulusType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="showStimulus" type="showStimulusType"/>
<xs:element name="showStimulusGrid" type="showStimulusGridType"/>
<xs:element name="matchingStimulusGrid" type="matchingStimulusGridType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="stimulusPause" type="stimulusPauseType"/>
<xs:element name="stimulusLabel" type="stimulusLabelType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="regionCodeStyle" type="regionCodeStyleType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="regionDragDrop" type="regionDragDropType"/>
<xs:element name="stimulusPresent" type="stimulusPresentType"/>
<xs:element name="stimulusImage" type="stimulusImageType"/>
<xs:element name="stimulusCodeImage" type="stimulusCodeImageType"/>
<xs:element name="stimulusCodeImageButton" type="stimulusCodeImageButtonType"/>
<xs:element name="stimulusCodeVideo" type="stimulusCodeVideoType"/>
<xs:element name="stimulusVideo" type="stimulusVideoType"/>
<xs:element name="stimulusCodeAudio" type="stimulusCodeAudioType"/>
<xs:element name="stimulusAudio" type="stimulusAudioType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="stimulusImageCapture" type="stimulusImageCaptureType"/>
<xs:element name="VideoPanel" type="VideoPanelType"/>
<xs:element name="AnnotationTimelinePanel" type="AnnotationTimelinePanelType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="startAudioRecorderWeb" type="startAudioRecorderWebType"/>
<xs:element name="startAudioRecorderApp" type="startAudioRecorderAppType"/>
<xs:element name="stopAudioRecorder" type="stopAudioRecorderType"/>
<xs:element name="startAudioRecorderTag" type="startAudioRecorderTagType"/>
<xs:element name="endAudioRecorderTag" type="endAudioRecorderTagType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="groupMemberCodeLabel" type="groupMemberCodeLabelType"/>
<xs:element name="groupMemberLabel" type="groupMemberLabelType"/>
<xs:element name="groupMessageLabel" type="groupMessageLabelType"/>
<xs:element name="groupResponseStimulusImage" type="groupResponseStimulusImageType"/>
<xs:element name="groupResponseFeedback" type="groupResponseFeedbackType"/>
<xs:element name="groupScoreLabel" type="groupScoreLabelType"/>
<xs:element name="groupChannelScoreLabel" type="groupChannelScoreLabelType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="submitGroupEvent" type="submitGroupEventType"/>
<xs:element name="sendGroupMessageButton" type="sendGroupMessageButtonType"/>
<xs:element name="sendGroupMessage" type="sendGroupMessageType"/>
<xs:element name="sendGroupStoredMessage" type="sendGroupStoredMessageType"/>
<xs:element name="streamGroupCanvas" type="streamGroupCanvasType"/>
<xs:element name="streamGroupCamera" type="streamGroupCameraType"/>
<xs:element name="sendGroupTokenMessage" type="sendGroupTokenMessageType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasTrueFalseErrorConditionType">
<xs:sequence>
<xs:element name="conditionTrue" type="conditionTrueType"/>
<xs:element name="conditionFalse" type="conditionFalseType"/>
<xs:element name="onError" type="onErrorType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_hasFrameRateTriggersType">
<xs:choice>
<xs:element name="addFrameTimeTrigger" type="addFrameTimeTriggerType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasMediaPlaybackType">
<xs:sequence>
<xs:element name="mediaLoaded" type="mediaLoadedType"/>
<xs:element name="mediaLoadFailed" type="mediaLoadFailedType"/>
<xs:element name="mediaPlaybackStarted" type="mediaPlaybackStartedType"/>
<xs:element name="mediaPlaybackComplete" type="mediaPlaybackCompleteType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasErrorSuccessType">
<xs:sequence>
<xs:element name="onSuccess" type="onSuccessType"/>
<xs:element name="onError" type="onErrorType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasThresholdType">
<xs:sequence>
<xs:element name="aboveThreshold" type="aboveThresholdType"/>
<xs:element name="withinThreshold" type="withinThresholdType"/>
</xs:sequence>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasTrueFalseConditionType">
<xs:sequence>
<xs:element name="conditionTrue" type="conditionTrueType"/>
<xs:element name="conditionFalse" type="conditionFalseType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_touchInputStartTypeType">
<xs:choice>
<xs:element name="htmlText" type="htmlTextType"/>
<xs:element name="htmlTokenText" type="htmlTokenTextType"/>
<xs:element name="evaluateTokenText" type="evaluateTokenTextType"/>
<xs:element name="logTokenText" type="logTokenTextType"/>
<xs:element name="plainText" type="plainTextType"/>
<xs:element name="image" type="imageType"/>
<xs:element name="menuItem" type="menuItemType"/>
<xs:element name="withStimuli" type="withStimuliType"/>
<xs:element name="groupStimuli" type="groupStimuliType"/>
<xs:element name="loadStimulus" type="loadStimulusType"/>
<xs:element name="loadStimulusPlugin" type="loadStimulusPluginType"/>
<xs:element name="withMatchingStimulus" type="withMatchingStimulusType"/>
<xs:element name="loadSdCardStimulus" type="loadSdCardStimulusType"/>
<xs:element name="currentStimulusHasTag" type="currentStimulusHasTagType"/>
<xs:element name="clearStimulusResponses" type="clearStimulusResponsesType"/>
<xs:element name="validateStimuliResponses" type="validateStimuliResponsesType"/>
<xs:element name="stimulusExists" type="stimulusExistsType"/>
<xs:element name="showStimuliReport" type="showStimuliReportType"/>
<xs:element name="sendStimuliReport" type="sendStimuliReportType"/>
<xs:element name="targetButton" type="targetButtonType"/>
<xs:element name="hotKeyInput" type="hotKeyInputType"/>
<xs:element name="actionButton" type="actionButtonType"/>
<xs:element name="actionTokenButton" type="actionTokenButtonType"/>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="svgLoadGroups" type="svgLoadGroupsType"/>
<xs:element name="stimulusButton" type="stimulusButtonType"/>
<xs:element name="stimulusSlider" type="stimulusSliderType"/>
<xs:element name="touchInputLabelButton" type="touchInputLabelButtonType"/>
<xs:element name="touchInputImageButton" type="touchInputImageButtonType"/>
<xs:element name="touchInputVideoButton" type="touchInputVideoButtonType"/>
<xs:element name="touchInputCapture" type="touchInputCaptureType"/>
<xs:element name="touchInputStop" type="touchInputStopType"/>
<xs:element name="ratingButton" type="ratingButtonType"/>
<xs:element name="ratingRadioButton" type="ratingRadioButtonType"/>
<xs:element name="ratingCheckbox" type="ratingCheckboxType"/>
<xs:element name="stimulusFreeText" type="stimulusFreeTextType"/>
<xs:element name="stimulusRatingButton" type="stimulusRatingButtonType"/>
<xs:element name="stimulusRatingRadio" type="stimulusRatingRadioType"/>
<xs:element name="stimulusRatingCheckbox" type="stimulusRatingCheckboxType"/>
<xs:element name="stimulusHasRatingOptions" type="stimulusHasRatingOptionsType"/>
<xs:element name="clearStimulusResponse" type="clearStimulusResponseType"/>
<xs:element name="stimulusHasResponse" type="stimulusHasResponseType"/>
<xs:element name="setStimulusCodeResponse" type="setStimulusCodeResponseType"/>
<xs:element name="addStimulusCodeResponseValidation" type="addStimulusCodeResponseValidationType"/>
<xs:element name="ratingFooterButton" type="ratingFooterButtonType"/>
<xs:element name="targetFooterButton" type="targetFooterButtonType"/>
<xs:element name="actionFooterButton" type="actionFooterButtonType"/>
<xs:element name="addPadding" type="addPaddingType"/>
<xs:element name="localStorageData" type="localStorageDataType"/>
<xs:element name="stimuliValidation" type="stimuliValidationType"/>
<xs:element name="addKeyboardDebug" type="addKeyboardDebugType"/>
<xs:element name="uploadUsersDataMenu" type="uploadUsersDataMenuType"/>
<xs:element name="addDebugWidgets" type="addDebugWidgetsType"/>
<xs:element name="allMetadataFields" type="allMetadataFieldsType"/>
<xs:element name="metadataField" type="metadataFieldType"/>
<xs:element name="stimulusMetadataField" type="stimulusMetadataFieldType"/>
<xs:element name="metadataFieldConnection" type="metadataFieldConnectionType"/>
<xs:element name="metadataFieldVisibilityDependant" type="metadataFieldVisibilityDependantType"/>
<xs:element name="metadataFieldDateTriggered" type="metadataFieldDateTriggeredType"/>
<xs:element name="saveMetadataButton" type="saveMetadataButtonType"/>
<xs:element name="createUserButton" type="createUserButtonType"/>
<xs:element name="switchUserIdButton" type="switchUserIdButtonType"/>
<xs:element name="selectUserMenu" type="selectUserMenuType"/>
<xs:element name="selectLocaleMenu" type="selectLocaleMenuType"/>
<xs:element name="eraseLocalStorageButton" type="eraseLocalStorageButtonType"/>
<xs:element name="eraseUsersDataButton" type="eraseUsersDataButtonType"/>
<xs:element name="showCurrentMs" type="showCurrentMsType"/>
<xs:element name="serverValueAssign" type="serverValueAssignType"/>
<xs:element name="serverValueComplete" type="serverValueCompleteType"/>
<xs:element name="cancelPauseTimers" type="cancelPauseTimersType"/>
<xs:element name="cancelPauseAll" type="cancelPauseAllType"/>
<xs:element name="showStimulusProgress" type="showStimulusProgressType"/>
<xs:element name="displayCompletionCode" type="displayCompletionCodeType"/>
<xs:element name="generateCompletionCode" type="generateCompletionCodeType"/>
<xs:element name="sendAllData" type="sendAllDataType"/>
<xs:element name="sendMetadata" type="sendMetadataType"/>
<xs:element name="redirectToUrl" type="redirectToUrlType"/>
<xs:element name="eraseLocalStorageOnWindowClosing" type="eraseLocalStorageOnWindowClosingType"/>
<xs:element name="keepStimulus" type="keepStimulusType"/>
<xs:element name="removeMatchingStimulus" type="removeMatchingStimulusType"/>
<xs:element name="centrePage" type="centrePageType"/>
<xs:element name="clearPage" type="clearPageType"/>
<xs:element name="backgroundImage" type="backgroundImageType"/>
<xs:element name="allMenuItems" type="allMenuItemsType"/>
<xs:element name="prevStimulusButton" type="prevStimulusButtonType"/>
<xs:element name="nextStimulusButton" type="nextStimulusButtonType"/>
<xs:element name="nextStimulus" type="nextStimulusType"/>
<xs:element name="prevStimulus" type="prevStimulusType"/>
<xs:element name="nextMatchingStimulus" type="nextMatchingStimulusType"/>
<xs:element name="addKinTypeGui" type="addKinTypeGuiType"/>
<xs:element name="hasGetParameter" type="hasGetParameterType"/>
<xs:element name="hasMetadataValue" type="hasMetadataValueType"/>
<xs:element name="setMetadataValue" type="setMetadataValueType"/>
<xs:element name="matchOnEvalTokens" type="matchOnEvalTokensType"/>
<xs:element name="progressIndicator" type="progressIndicatorType"/>
<xs:element name="setMetadataEvalTokens" type="setMetadataEvalTokensType"/>
<xs:element name="activateRandomItem" type="activateRandomItemType"/>
<xs:element name="gotoPresenter" type="gotoPresenterType"/>
<xs:element name="gotoNextPresenter" type="gotoNextPresenterType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="audioButton" type="audioButtonType"/>
<xs:element name="preloadAllStimuli" type="preloadAllStimuliType"/>
<xs:element name="showStimulus" type="showStimulusType"/>
<xs:element name="showStimulusGrid" type="showStimulusGridType"/>
<xs:element name="matchingStimulusGrid" type="matchingStimulusGridType"/>
<xs:element name="pause" type="pauseType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="requestNotification" type="requestNotificationType"/>
<xs:element name="startTimer" type="startTimerType"/>
<xs:element name="compareTimer" type="compareTimerType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="logTimerValue" type="logTimerValueType"/>
<xs:element name="timerLabel" type="timerLabelType"/>
<xs:element name="randomMsPause" type="randomMsPauseType"/>
<xs:element name="evaluatePause" type="evaluatePauseType"/>
<xs:element name="addTimerTrigger" type="addTimerTriggerType"/>
<xs:element name="startFrameRateTimer" type="startFrameRateTimerType"/>
<xs:element name="addMediaTrigger" type="addMediaTriggerType"/>
<xs:element name="addRecorderDtmfTrigger" type="addRecorderDtmfTriggerType"/>
<xs:element name="addRecorderLevelTrigger" type="addRecorderLevelTriggerType"/>
<xs:element name="triggerDefinition" type="triggerDefinitionType"/>
<xs:element name="habituationParadigmListener" type="habituationParadigmListenerType"/>
<xs:element name="triggerMatching" type="triggerMatchingType"/>
<xs:element name="triggerRandom" type="triggerRandomType"/>
<xs:element name="resetTrigger" type="resetTriggerType"/>
<xs:element name="countdownLabel" type="countdownLabelType"/>
<xs:element name="stimulusPause" type="stimulusPauseType"/>
<xs:element name="stimulusLabel" type="stimulusLabelType"/>
<xs:element name="kinTypeStringDiagram" type="kinTypeStringDiagramType"/>
<xs:element name="loadKinTypeStringDiagram" type="loadKinTypeStringDiagramType"/>
<xs:element name="editableKinEntitesDiagram" type="editableKinEntitesDiagramType"/>
<xs:element name="existingUserCheck" type="existingUserCheckType"/>
<xs:element name="table" type="tableType"/>
<xs:element name="row" type="rowType"/>
<xs:element name="column" type="columnType"/>
<xs:element name="regionAppend" type="regionAppendType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="regionCodeStyle" type="regionCodeStyleType"/>
<xs:element name="regionReplace" type="regionReplaceType"/>
<xs:element name="regionClear" type="regionClearType"/>
<xs:element name="regionDragDrop" type="regionDragDropType"/>
<xs:element name="stimulusPresent" type="stimulusPresentType"/>
<xs:element name="stimulusImage" type="stimulusImageType"/>
<xs:element name="stimulusCodeImage" type="stimulusCodeImageType"/>
<xs:element name="stimulusCodeImageButton" type="stimulusCodeImageButtonType"/>
<xs:element name="stimulusCodeVideo" type="stimulusCodeVideoType"/>
<xs:element name="stimulusVideo" type="stimulusVideoType"/>
<xs:element name="stimulusCodeAudio" type="stimulusCodeAudioType"/>
<xs:element name="stimulusAudio" type="stimulusAudioType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="stimulusImageCapture" type="stimulusImageCaptureType"/>
<xs:element name="VideoPanel" type="VideoPanelType"/>
<xs:element name="AnnotationTimelinePanel" type="AnnotationTimelinePanelType"/>
<xs:element name="audioInputSelectWeb" type="audioInputSelectWebType"/>
<xs:element name="startAudioRecorderWeb" type="startAudioRecorderWebType"/>
<xs:element name="startAudioRecorderApp" type="startAudioRecorderAppType"/>
<xs:element name="stopAudioRecorder" type="stopAudioRecorderType"/>
<xs:element name="startAudioRecorderTag" type="startAudioRecorderTagType"/>
<xs:element name="endAudioRecorderTag" type="endAudioRecorderTagType"/>
<xs:element name="showHtmlPopup" type="showHtmlPopupType"/>
<xs:element name="helpDialogue" type="helpDialogueType"/>
<xs:element name="userInfo" type="userInfoType"/>
<xs:element name="versionData" type="versionDataType"/>
<xs:element name="showColourReport" type="showColourReportType"/>
<xs:element name="scoreLabel" type="scoreLabelType"/>
<xs:element name="clearCurrentScore" type="clearCurrentScoreType"/>
<xs:element name="scoreIncrement" type="scoreIncrementType"/>
<xs:element name="bestScoreAboveThreshold" type="bestScoreAboveThresholdType"/>
<xs:element name="totalScoreAboveThreshold" type="totalScoreAboveThresholdType"/>
<xs:element name="scoreAboveThreshold" type="scoreAboveThresholdType"/>
<xs:element name="resetStimulus" type="resetStimulusType"/>
<xs:element name="submitTestResults" type="submitTestResultsType"/>
<xs:element name="validateMetadata" type="validateMetadataType"/>
<xs:element name="transmitResults" type="transmitResultsType"/>
</xs:choice>
</xs:group>
<xs:group name="sequenceOnceOrdered_hasMediaLoadingButtonType">
<xs:sequence>
<xs:element name="mediaLoaded" type="mediaLoadedType"/>
<xs:element name="mediaLoadFailed" type="mediaLoadFailedType"/>
<xs:element name="onActivate" type="onActivateType"/>
</xs:sequence>
</xs:group>
<xs:group name="choiceAnyCount_isTimeCriticalType">
<xs:choice>
<xs:element name="disableButtonGroup" type="disableButtonGroupType"/>
<xs:element name="enableButtonGroup" type="enableButtonGroupType"/>
<xs:element name="hideButtonGroup" type="hideButtonGroupType"/>
<xs:element name="styleButtonGroup" type="styleButtonGroupType"/>
<xs:element name="showButtonGroup" type="showButtonGroupType"/>
<xs:element name="requestFocus" type="requestFocusType"/>
<xs:element name="logTimeStamp" type="logTimeStampType"/>
<xs:element name="zeroStimulusStopwatch" type="zeroStimulusStopwatchType"/>
<xs:element name="stopStimulusStopwatch" type="stopStimulusStopwatchType"/>
<xs:element name="hardwareTimeStamp" type="hardwareTimeStampType"/>
<xs:element name="recorderToneInjection" type="recorderToneInjectionType"/>
<xs:element name="dtmfTone" type="dtmfToneType"/>
<xs:element name="doLater" type="doLaterType"/>
<xs:element name="clearTimer" type="clearTimerType"/>
<xs:element name="regionStyle" type="regionStyleType"/>
<xs:element name="playMedia" type="playMediaType"/>
<xs:element name="rewindMedia" type="rewindMediaType"/>
<xs:element name="pauseMedia" type="pauseMediaType"/>
<xs:element name="logMediaTimeStamp" type="logMediaTimeStampType"/>
<xs:element name="stopAudioRecorder" type="stopAudioRecorderType"/>
<xs:element name="startAudioRecorderTag" type="startAudioRecorderTagType"/>
<xs:element name="endAudioRecorderTag" type="endAudioRecorderTagType"/>
</xs:choice>
</xs:group>
<xs:group name="choiceAnyCount_groupMemberActivityType">
<xs:choice>
<xs:element name="groupMemberActivity" type="groupMemberActivityType"/>
</xs:choice>
</xs:group>
</xs:schema>
